<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="CUIGUO supplies a common offical workstation by mcp servers.">
    <title>Chatbot</title>
    <style>
        ::-webkit-scrollbar {
            display: none;
        }

        .loading {
            all: initial;
            position: fixed;
            top: calc(50% - 35px);
            left: calc(50% - 35px);
            display: flex;
            width: 70px;
            height: 70px;
            border: 4px solid #1867C0;
            border-top-color: rgba(0, 0, 0, 0.2);
            border-right-color: rgba(0, 0, 0, 0.2);
            border-bottom-color: rgba(0, 0, 0, 0.2);
            border-radius: 100%;
            overflow: hidden;

            animation: circle infinite 1s linear;
        }

        @keyframes circle {
            0% {
                transform: rotate(0);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <div id="loading" class="loading"></div>

    <!-- MDI -->
    <!-- https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/MaterialDesign-Webfont/7.4.47/css/materialdesignicons.min.css -->
    <link href="../lib/css/materialdesignicons.min.css" rel="stylesheet" ref="preload">

    <!-- Keep the order, vue should be the first -->
    <script src="../lib/js/vue.global.prod.min.js"></script>

    <!-- Vuetify -->
    <script src="../lib/js/vuetify.js"></script>
    <link href="../lib/css/vuetify.css" rel="stylesheet">

    <!-- Vue i18n -->
    <script src="../lib/js/vue-i18n.global.prod.min.js"></script>
    <script src="../lib/js/iconify-icon.min.js"></script>

    <!-- Pinia -->
    <script src="../lib/js/vue-demi.lib.index.iife.min.js"></script>
    <script src="../lib/js/pinia.iife.prod.js"></script>
    <script src="../lib/js/pinia-persist.umd.min.js"></script>

    <!-- MD -->
    <link href="../lib/css/md-editor-v3-style.min.css" rel="stylesheet">
    <script src="../lib/js/md-editor-v3-lib-umd.min.js"></script>

    <!-- Lottie -->
    <script src="../lib/js/lottie.min.js"></script>
    <!-- Docx mammoth -->
    <script src="../lib/js/mammoth.browser.js"></script>

    <!-- Vue Draggable -->
    <script src="../lib/js/Sortable.min.js"></script>
    <script src="../lib/js/vuedraggable.umd.min.js"></script>

    <script>
        window.onload = function () {
            const lottie = document.getElementById('lottie');
            if (lottie) lottie.style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        };

        // Suppress specific DevTools autofill errors
        const originalConsoleError = console.error;
        console.error = function(...args) {
            if (args.some(arg => typeof arg === 'string' &&
                (arg.includes('Autofill.enable') || arg.includes('Autofill.setAddresses')))) {
                return;
            }
            originalConsoleError.apply(console, args);
        };
    </script>

    <style scoped lanMCP="scss">
        [v-cloak] {
            display: none;
        }

        .chat-bot {
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .fill-area {
            height: 20px
        }

        .dialog-card {
            width: 960px;
            max-width: 100vw;
            max-height: calc(70vh + 3rem);
        }

        #lottie {
            display: none;
            height: calc(99vh - 50px);
            max-height: calc(100% - 100px);
        }

        .left-icon {
            margin-bottom: 0.8rem;
        }

        .input-area {
            background-color: white;
            display: flex;
            padding-inline: 21.5px;
            margin-inline: 21.5px;
            width: 100%;
            position: fixed;
            left: 50%;
            transform: translate(-50%);
            bottom: 0;

            .input-panel {
                flex: 1;
                border-top: 5px solid white;
                max-width: 1280px;
                border-radius: 5px;
                margin: 0 auto;
            }

            .input-box textarea {
                margin-bottom: 1px;
            }

            .input-box textarea::-webkit-scrollbar {
                display: none;

            }

            .input-icon {
                margin: 0 10px 34px 10px;
                /* top left bot right*/
            }
        }

        .chat-images {
            width: 25px;
            max-height: 40px;
            transition: all 0.2s;
            /* margin-bottom: 20px; */

            &:hover {
                transition: all 0.2s;
                opacity: 0.5;
                filter: grayscale(100%);
                cursor: not-allowed;
            }
        }

        .shadow {
            box-shadow: 1px 1px 7px #1867C0;
        }

        .hidden {
            overflow: hidden;
        }

        .chat-message {
            border-bottom: 1px solid #e5e7eb;
        }

        .message {
            margin: 0 auto;
            display: flex;
        }

        .conversation-area {
            margin: 6px 4px 4px 4px;
            /* top left bot right*/
        }

        .fade-enter-active,
        .fade-leave-active {
            transition: all 0.5s ease;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
            transform: translateX(35px);
        }

        .toolbox-button {
            position: fixed;
            background-color: #1867C0;
            bottom: 194px;
            right: -46px;
            z-index: 999;
            padding: 0.5rem 1rem;
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
            box-shadow: 1px 1px 9px #1867C0;
            transition: all 0.5s;
            cursor: pointer;

            &:hover {
                box-shadow: 1px 1px 18px #1867C0;
                right: 0px;
                transition: all 0.5s;
            }

        }

        .history-images {
            &:hover {
                cursor: zoom-in;
            }
        }

        .md-preview {
            width: 100vw;
            max-width: 100%;
        }

        .md-editor-preview p {
            word-break: break-word;
        }

        .toolbox {
            z-index: 99;
            position: fixed;
            bottom: 194px;
            right: 5px;
        }

        .rotation {
            font-size: 1.5rem;
            animation: rotation 2s linear infinite;
        }

        .ghost {
            opacity: 0.5;
            background: #E3F2FD;
        }

        .list-draggable {
            height: calc(100% - 38px);
            /* background-color: lightblue; */
        }

        .bgc {
            background-color: lightblue;
        }

        @keyframes rotation {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        ::-webkit-scrollbar {
            display: block;
            block-size: 5px;
            inline-size: 5px;
        }

        ::-webkit-scrollbar-track {
            background-color: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background-color: lightgrey;
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: grey;
        }
    </style>
</head>

<body>
    <div id="app" v-cloak>
        <v-app>
            <v-container v-show="messageStore.conversation.length === 0">
                <div id="lottie" class="text-center text-h5">
                    {{$t('$vuetify.dataIterator.title')}}
                    <!-- <a href="https://github.com/AI-QL/chat-ui" style="color: #1867C0"
                        class="font-weight-bold text-decoration-none" target="_blank">
                        <v-icon class="mb-2">mdi-github</v-icon>
                        {{$t('$vuetify.dataIterator.title')}}</a> -->
                </div>
            </v-container>
            <v-container v-show="messageStore.conversation.length > 0" class="chat-bot">
                <tuui-chat-box :messages="messageStore.conversation" :size="settingStore.avatarSize"
                    :language="languageStore.getLocale"></tuui-chat-box>
                <div class="fill-area"></div>
            </v-container>
            <div class="input-area">
                <v-sheet elevation="0" class="input-panel d-flex align-end px-1">
                    <v-speed-dial transition="expand-transition" offset="10">
                        <template v-slot:activator="{ props: activatorProps }">
                            <v-btn v-bind="activatorProps" size="small" icon="mdi-cog" absolute
                                class="input-icon"></v-btn>
                        </template>
                        <v-btn key="4" variant="elevated" @click="settingStore.initDialog" icon="mdi-api"
                            v-tooltip:end="$t('$vuetify.dataIterator.i.title')">
                        </v-btn>
                        <v-badge key="3" color="transparent" location='top left'>
                            <template v-slot:badge>
                                <iconify-icon :icon="languageStore.getIcon2()"></iconify-icon>
                            </template>
                            <v-menu transition="fade-transition">
                                <template v-slot:activator="{ props }">
                                    <v-btn variant="elevated" v-bind="props" icon="mdi-translate"
                                        v-tooltip:end="$t('$vuetify.dataIterator.l.title')">
                                    </v-btn>
                                </template>
                                <v-list class='mb-2'>
                                    <v-list-item v-for="n in languageStore.list" :key="n.value"
                                        @click="languageStore.change(n.value)" density="compact">
                                        <template v-slot:prepend>
                                            <iconify-icon class='mr-3'
                                                :icon="languageStore.getIcon(n.name)"></iconify-icon>
                                        </template>
                                        <v-list-item-title v-text="n.title"></v-list-item-title>
                                    </v-list-item>
                                </v-list>
                            </v-menu>
                        </v-badge>
                        <v-btn @click="settingStore.agentDialog = true" variant="elevated" icon="mdi-account-supervisor"
                            v-tooltip:end="$t('$vuetify.dataIterator.a.title')">
                        </v-btn>
                        <!-- mcpStore.getServers -->
                        <v-btn v-if="false" @click="resourceStore.resourceDialog = true"
                            variant="elevated" icon="mdi-database" v-tooltip:end="$t('$vuetify.dataIterator.r.title')">
                        </v-btn>
                        <v-badge key="1" :content="historyStore.conversation.length" color="info" max="99"
                            location='top left'>
                            <v-btn variant="elevated" icon="mdi-list-box" @click="settingStore.configHistory = true"
                                v-tooltip:end="$t('$vuetify.dataIterator.q.title')">
                            </v-btn>
                        </v-badge>
                    </v-speed-dial>
                    <v-container>
                        <v-row>
                            <v-textarea class="input-box" dirty color="primary" type="text" variant="solo" counter
                                clearable @keydown="messageStore.handleKeydown" v-model="messageStore.userMessage"
                                :label="" @focus="settingStore.setInputRow(2,0)" @blur="settingStore.setInputRow(1,150)"
                                :rows="settingStore.inputRow" auto-grow max-rows="15">
                                <template v-slot:prepend-inner>
                                    <v-container>
                                        <v-row>
                                            <v-img v-if="messageStore.base64" class="chat-images mt-1"
                                                :src="messageStore.base64" @click="messageStore.images=[]"></v-img>
                                            <v-file-input v-else @click.stop accept="image/*" hide-input
                                                v-model="messageStore.images"
                                                prepend-icon="mdi-plus-circle-outline"></v-file-input>
                                        </v-row>
                                    </v-container>
                                </template>
                            </v-textarea>
                        </v-row>
                    </v-container>
                    <div class="input-icon">
                        <v-btn v-if="messageStore.userMessage" size="small" color="primary" variant="elevated"
                            @click="messageStore.sendMessage" icon="mdi-arrow-up">
                        </v-btn>
                        <v-btn v-else-if="messageStore.generating" size="small" color="primary" variant="elevated"
                            @click="messageStore.stop" icon="mdi-stop"></v-btn>
                        <v-speed-dial v-else-if="messageStore.conversation.length > 0" location="bottom center"
                            transition="expand-transition">
                            <template v-slot:activator="{ props: activatorProps }">
                                <v-btn v-bind="activatorProps" size="small" icon="mdi-dots-horizontal"
                                    color="primary"></v-btn>
                            </template>
                            <v-btn key="2" size="small" color="primary" variant="elevated"
                                @click="messageStore.resendMessage" icon="mdi-autorenew"
                                v-tooltip:start="$t('$vuetify.dataIterator.g.reg')">
                            </v-btn>
                            <v-btn key="1" color="primary" variant="elevated" @click="messageStore.init()"
                                icon="mdi-pencil-plus" v-tooltip:start="$t('$vuetify.dataIterator.g.new')">
                            </v-btn>
                        </v-speed-dial>
                        <v-btn v-else size="small" :color="mcpStore.getServers ? 'primary': 'grey'" variant="elevated"
                            @click="mcpStore.getServers ? promptStore.promptDialog = true : false"
                            icon="mdi-account-edit">
                        </v-btn>
                    </div>
                </v-sheet>
            </div>

            <!-- snackbar -->
            <v-snackbar v-model="snackbarStore.isShow" timeout="4000" :color="snackbarStore.type" location="top">
                <div class="d-flex align-center">
                    <v-icon class="mr-2">{{ snackbarStore.getIcon() }}</v-icon>
                    <span>{{$t(snackbarStore.message)}}</span>
                </div>

                <template v-slot:actions>
                    <v-btn icon variant="text" @click="snackbarStore.isShow = false">
                        <v-icon>mdi-close</v-icon>
                    </v-btn>
                </template>
            </v-snackbar>

            <v-dialog v-model="settingStore.configHistory" class="dialog-card">
                <v-card prepend-icon="mdi-history" :title="$t('$vuetify.dataIterator.q.title')" flat>
                    <template v-slot:append>
                        <v-card-actions>
                            <v-spacer></v-spacer>
                            <v-btn color="primary" icon="mdi-download" @click="historyStore.downloadHistory"></v-btn>
                            <v-btn color="error" icon="mdi-delete-off-outline" @click="historyStore.resetState"></v-btn>
                        </v-card-actions>
                    </template>

                    <v-data-iterator :items="historyStore.conversation" items-per-page="-1" class="ma-4 mt-0">
                        <template v-slot:default="{ items }">
                            <transition-group name="fade">
                                <v-card v-for="(item, index) in items" variant="plain" :key="item.raw.id">
                                    <v-divider></v-divider>
                                    <v-card-item>
                                        <template v-slot:prepend>
                                            <v-btn :color="historyStore.getColor(index)" class="mr-3" icon size="small"
                                                @click="historyStore.select(index)">
                                                <b>{{item.raw.history.length}}</b>
                                            </v-btn>
                                        </template>
                                        <v-card-subtitle class="mt-1 font-weight-bold">
                                            {{ item.raw.history[0]?.content[1]?.text || item.raw.history[0]?.content ||
                                            "NA" }}
                                        </v-card-subtitle>
                                        <v-card-subtitle>
                                            {{ item.raw.history[item.raw.history.length-1]?.content[1]?.text ||
                                            item.raw.history[item.raw.history.length-1]?.content || "NA" }}
                                        </v-card-subtitle>
                                        <template v-slot:append>
                                            <v-btn color="primary" icon="mdi-download" variant="text"
                                                @click="historyStore.downloadById(index)"></v-btn>
                                            <v-btn icon="mdi-delete-outline" variant="text"
                                                @click="historyStore.deleteById(index)"></v-btn>
                                        </template>
                                    </v-card-item>
                                </v-card>
                            </transition-group>
                        </template>
                    </v-data-iterator>
                </v-card>

            </v-dialog>
            <!-- dialog -->
            <v-dialog v-model="settingStore.configDialog" class="dialog-card">
                <v-card prepend-icon="mdi-cog-outline" :title="$t('$vuetify.dataIterator.i.title')">
                    <template v-slot:append>
                        <v-card-actions>
                            <v-spacer></v-spacer>
                            <v-btn color="error" icon="mdi-refresh" @click="chatbotStore.resetState"></v-btn>
                        </v-card-actions>
                    </template>

                    <v-card-text class="pb-0">
                        <!-- ---------------------------------------------- -->
                        <!-- APIKEY -->
                        <!-- ---------------------------------------------- -->
                        <v-text-field density='compact' color="primary" variant="outlined"
                            :append-inner-icon="settingStore.apiKeyShow ? 'mdi-eye-off' : 'mdi-eye'"
                            :type="settingStore.apiKeyShow ? 'text' : 'password'" v-model="chatbotStore.apiKey"
                            class="px-2 mb-4" :label="$t('$vuetify.dataIterator.i.apikey')" prepend-inner-icon="mdi-key"
                            clearable hide-details
                            @click:append-inner="settingStore.apiKeyShow = !settingStore.apiKeyShow"></v-text-field>

                        <v-expansion-panels static tile variant="accordion" class="px-2 mb-4">
                            <v-expansion-panel>
                                <v-expansion-panel-title v-slot="{ expanded }">
                                    <v-icon icon="mdi-web" start></v-icon>
                                    <v-row no-gutters class="hidden">
                                        <span v-if="expanded">{{$t('$vuetify.dataIterator.i.endpoint')}}</span>
                                        <span v-else>
                                            <v-chip label color="primary" class="ma-1">
                                                {{chatbotStore.url}}{{chatbotStore.path}}
                                            </v-chip>

                                            <v-chip label color="primary" class="ma-1">
                                                {{chatbotStore.model || "No model" }}
                                            </v-chip>
                                        </span>
                                </v-expansion-panel-title>

                                <v-expansion-panel-text>
                                    <!-- ---------------------------------------------- -->
                                    <!-- URL -->
                                    <!-- ---------------------------------------------- -->
                                    <v-combobox density='compact' class="px-2"
                                        :label="$t('$vuetify.dataIterator.i.url')" :items="defaultChoiceStore.url"
                                        v-model="chatbotStore.url" variant="outlined">
                                    </v-combobox>

                                    <!-- ---------------------------------------------- -->
                                    <!-- Path -->
                                    <!-- ---------------------------------------------- -->
                                    <v-combobox density='compact' class="px-2"
                                        :label="$t('$vuetify.dataIterator.i.path')" :items="defaultChoiceStore.path"
                                        v-model="chatbotStore.path" variant="outlined">
                                    </v-combobox>

                                    <!-- ---------------------------------------------- -->
                                    <!-- Model -->
                                    <!-- ---------------------------------------------- -->
                                    <v-combobox density='compact' class="px-2"
                                        :label="$t('$vuetify.dataIterator.i.model')" :items="defaultChoiceStore.model"
                                        v-model="chatbotStore.model" variant="outlined">
                                    </v-combobox>
                                </v-expansion-panel-text>
                            </v-expansion-panel>

                            <v-expansion-panel>
                                <v-expansion-panel-title v-slot="{ expanded }">
                                    <v-icon icon="mdi-account-key" start></v-icon>
                                    <v-row no-gutters class="hidden">
                                        <span v-if="expanded">{{ $t('$vuetify.dataIterator.i.advanced') }}</span>
                                        <span v-else>
                                            <v-chip label color="primary" class="ma-1">
                                                {{ chatbotStore.stream ? "Stream" : "Stream: off" }}
                                            </v-chip>
                                            <v-chip label color="primary" class="ma-1">
                                                {{ chatbotStore.mcp ? "MCP" : "MCP: off" }}
                                            </v-chip>
                                            <v-chip label color="primary" class="ma-1">
                                                {{chatbotStore.max_tokens_type}}
                                                {{": "}}
                                                {{ chatbotStore.max_tokens_value ? chatbotStore.max_tokens_value :
                                                "default" }}
                                            </v-chip>
                                            <v-chip label color="primary" class="ma-1">
                                                {{"temperature: "}}
                                                {{ chatbotStore.temperature ? chatbotStore.temperature :
                                                "default" }}
                                            </v-chip>
                                            <v-chip label color="primary" class="ma-1">
                                                {{"top_p: "}}
                                                {{ chatbotStore.top_p ? chatbotStore.top_p :
                                                "default" }}
                                            </v-chip>
                                            <v-chip label color="primary" class="ma-1">
                                                {{ chatbotStore.authPrefix }}
                                            </v-chip>
                                            <v-chip label color="primary" class="ma-1">
                                                {{ chatbotStore.contentType }}
                                            </v-chip>
                                        </span>
                                </v-expansion-panel-title>

                                <v-expansion-panel-text>
                                    <v-row class="px-3 mt-2 mr-2">

                                        <v-combobox class="px-2" density='compact'
                                            :label="$t('$vuetify.dataIterator.i.reasoning')"
                                            v-model="chatbotStore.reasoning_effort" clearable
                                            :items="defaultChoiceStore.reasoning_efforts" variant="outlined">
                                        </v-combobox>
                                        <v-spacer></v-spacer>
                                        <v-checkbox v-model="chatbotStore.stream"
                                            :label="$t('$vuetify.dataIterator.i.stream')" density='compact'
                                            color="primary">
                                        </v-checkbox>
                                        <v-checkbox v-if="mcpStore.getServers" v-model="chatbotStore.mcp"
                                            :label="$t('$vuetify.dataIterator.i.mcp')" density='compact'
                                            color="primary">
                                        </v-checkbox>
                                    </v-row>
                                    <v-row class="px-3 mt-4 mb-0">
                                        <v-combobox class="px-2" density='compact'
                                            :label="$t('$vuetify.dataIterator.i.maxTokensPrefix')"
                                            :items="defaultChoiceStore.max_tokens_type"
                                            v-model="chatbotStore.max_tokens_type" variant="outlined">
                                        </v-combobox>
                                        <v-combobox class="px-2" density='compact' label="MaxTokenValue"
                                            v-model="chatbotStore.max_tokens_value" type='number' single-line
                                            variant="outlined">
                                        </v-combobox>
                                    </v-row>
                                    <v-row class="px-3 mt-0 mb-0">
                                        <v-combobox class="px-2" density='compact'
                                            :label="$t('$vuetify.dataIterator.i.temperature')"
                                            :items="defaultChoiceStore.temperature" type='number'
                                            v-model="chatbotStore.temperature" variant="outlined"
                                            :rules="[value => !isNaN(value) && parseFloat(value) >= 0 && parseFloat(value) <= 2]">
                                        </v-combobox>
                                        <v-combobox class="px-2" density='compact'
                                            :label="$t('$vuetify.dataIterator.i.topP')" v-model="chatbotStore.top_p"
                                            type='number' variant="outlined"
                                            :rules="[value => !isNaN(value) && parseFloat(value) >= 0 && parseFloat(value) <= 1]">
                                        </v-combobox>
                                    </v-row>
                                    <v-combobox class="px-2" density='compact'
                                        :label="$t('$vuetify.dataIterator.i.contentType')"
                                        v-model="chatbotStore.contentType" variant="outlined">
                                    </v-combobox>
                                    <v-combobox class="px-2" density='compact'
                                        :label="$t('$vuetify.dataIterator.i.authPrefix')"
                                        :items="defaultChoiceStore.authPrefix" v-model="chatbotStore.authPrefix"
                                        variant="outlined">
                                    </v-combobox>
                                </v-expansion-panel-text>
                            </v-expansion-panel>
                        </v-expansion-panels>

                        <!-- Dialog Btn -->
                        <v-card-actions>
                            <v-file-input prepend-icon="" prepend-inner-icon="mdi-upload" class="mr-2"
                                variant="outlined" v-model="configFile"
                                :label="$t('$vuetify.dataIterator.i.configFile')" accept="application/json"
                                single-line></v-file-input>

                            <v-spacer></v-spacer>
                            <v-btn variant="flat" color="primary" @click="settingStore.configDialog = false">OK</v-btn>
                        </v-card-actions>
                    </v-card-text>
                </v-card>
            </v-dialog>
            <v-dialog v-model="promptStore.promptDialog" class="dialog-card">
                <v-card prepend-icon="mdi-account-cog" :title="$t('$vuetify.dataIterator.p.title')">
                    <v-data-iterator :items="promptStore.promptList" :search="promptStore.search" items-per-page="-1"
                        @update:options="promptStore.loadPrompts" :loading="promptStore.loading">
                        <template v-slot:header>
                            <v-toolbar class="px-2">
                                <v-text-field v-model="promptStore.search" density="comfortable" placeholder="Search"
                                    prepend-inner-icon="mdi-magnify" width="100vw" max-width="400px" variant="solo"
                                    clearable hide-details></v-text-field>
                            </v-toolbar>
                        </template>
                        <template v-slot:default="{ items }">
                            <v-container class="pa-2" fluid>
                                <v-row dense>
                                    <v-col v-for="item in items" :key="item.raw.title +':'+ item.raw.name" cols="auto"
                                        class="flex-fill">
                                        <v-card border flat>
                                            <v-card-item :subtitle="item.raw.name" class="mb-2" :title="item.raw.title">
                                                <template v-slot:append>
                                                    <v-btn icon="mdi-lead-pencil" size="small" text="Read" border flat
                                                        @click="promptStore.select(item.raw)">
                                                    </v-btn>
                                                </template>
                                            </v-card-item>
                                            <v-card-text>{{ item.raw.description }}</v-card-text>
                                        </v-card>
                                    </v-col>
                                </v-row>
                            </v-container>
                        </template>
                    </v-data-iterator>
                </v-card>
            </v-dialog>
            <v-dialog v-model="promptStore.promptSheet" class="dialog-card">
                <v-card prepend-icon="mdi-account-cog-outline"
                    :title="$t('$vuetify.dataIterator.p.sheet') + ' - ' + promptStore.promptSelect.title"
                    :subtitle="promptStore.promptSelect.name">
                    <v-divider></v-divider>
                    <v-card-text>
                        <div>{{promptStore.promptSelect.description}}</div>
                        <div v-if="promptStore.promptSelect.arguments">
                            <br>
                            <v-textarea class="mx-2" v-for="argument in promptStore.promptSelect.arguments"
                                color="primary" type="text" variant="outlined" v-model="argument.content"
                                :label="argument.name" rows="1" auto-grow>
                        </div>
                        </v-textarea>
                        <v-card-actions>
                            <v-spacer></v-spacer>
                            <v-btn class="pt-0" variant="flat" color="primary"
                                @click="messageStore.applyPrompt(promptStore.fetchSelect())">Get</v-btn>
                        </v-card-actions>
                    </v-card-text>
                </v-card>
            </v-dialog>
            <v-dialog v-model="resourceStore.resourceDialog" class="dialog-card" scrollable>
                <v-card prepend-icon="mdi-database" :title="$t('$vuetify.dataIterator.r.title')">
                    <v-tabs :items="mcpStore.listServerResources()" v-model="resourceStore.tab" color="primary">
                        <template v-slot:tab="{ item }">
                            <v-tab :text="item.name" :value="item.name" class="text-none"></v-tab>
                        </template>
                    </v-tabs>
                    <v-divider></v-divider>
                    <v-card-text>
                        <v-tabs-window v-model="resourceStore.tab">
                            <v-tabs-window-item v-for="item in mcpStore.listServerResources()" :value="item.name">
                                <v-data-iterator :items="resourceStore.resourceTemplatesList" items-per-page="-1"
                                    @update:options="resourceStore.loadTemplates(item.templatesList)"
                                    :loading="resourceStore.loadingTemplates">
                                    <template v-slot:default="{ items }">
                                        <v-container>
                                            <v-row dense>
                                                <v-col v-for="item in items"
                                                    :key="item.raw.uriTemplate +':'+ item.raw.name" cols="auto"
                                                    class="flex-fill">
                                                    <v-card border flat>
                                                        <v-card-item :subtitle="item.raw.uriTemplate" class="mb-2"
                                                            :title="item.raw.name">
                                                        </v-card-item>
                                                        <v-card-text>{{ item.raw.description }}</v-card-text>
                                                    </v-card>
                                                </v-col>
                                            </v-row>
                                        </v-container>
                                    </template>
                                </v-data-iterator>
                                <v-data-iterator :items="resourceStore.resourceList" items-per-page="-1"
                                    @update:options="resourceStore.loadResources(item.list)"
                                    :loading="resourceStore.loadingResources">
                                    <template v-slot:default="{ items }">
                                        <v-container>
                                            <v-expansion-panels>
                                                <v-expansion-panel v-for="item in items"
                                                    :key="item.raw.uri +':'+ item.raw.name"
                                                    :text="JSON.stringify(item.raw)"
                                                    :title="item.raw.name +' - '+ item.raw.uri">
                                                </v-expansion-panel>
                                            </v-expansion-panels>
                                        </v-container>
                                    </template>
                                </v-data-iterator>
                            </v-tabs-window-item>
                        </v-tabs-window>
                    </v-card-text>
                </v-card>
            </v-dialog>
            <v-dialog v-model="settingStore.agentDialog" class="dialog-card">
                <v-card prepend-icon="mdi-history" :title="$t('$vuetify.dataIterator.a.title')"
                    style="overflow-x: auto">
                    <template v-slot:append>
                        <v-card-actions>
                            <v-spacer></v-spacer>
                            <v-btn color="error" icon="mdi-delete-off-outline" @click="agentStore.initAgent()"></v-btn>
                        </v-card-actions>
                    </template>
                    <!-- board column -->
                    <v-container class="pt-0">
                        <v-row justify="center" class="mx-0 mb-2">
                            <v-col cols="auto" v-for="column in agentStore.columns" :key="column.key" class="flex-fill">
                                <v-divider></v-divider>
                                <div class="d-flex align-center ma-1">
                                    <h5 class="font-weight-bold">{{ column.key }}</h5>
                                    <v-spacer></v-spacer>
                                    <!-- add new card button -->
                                    <v-btn variant="text" rounded icon="mdi-plus" size="small" color="primary"
                                        @click="column.isAddVisible = !column.isAddVisible">
                                    </v-btn>
                                </div>

                                <!-- add new card form -->
                                <v-card v-show="column.isAddVisible" class="pa-5 mb-4">
                                    <v-text-field color="primary" v-model="column.addTitle" label="Title"
                                        variant="underlined" hideDetails autofocus
                                        @keyup.enter="agentStore.addCard(column)"
                                        @keyup.esc="column.isAddVisible = false"></v-text-field>
                                    <div class="mt-3 d-flex flex-md-row flex-column">
                                        <v-btn class="flex-fill ma-1" size="small"
                                            @click="column.isAddVisible = !column.isAddVisible">Cancel</v-btn>
                                        <v-spacer></v-spacer>
                                        <v-btn class="flex-fill ma-1" size="small" color="primary"
                                            @click="agentStore.addCard(column)">Add</v-btn>
                                    </div>
                                </v-card>

                                <!-- draggable cards -->
                                <vuedraggable v-model="column.cards" v-bind="agentStore.getDragOption"
                                    :class="{'list-draggable': !column.isAddVisible}" @change="column.callback"
                                    item-key="id">
                                    <template #item="{ element, index }">
                                        <v-card @click="agentStore.editCard(element)" class="pa-4 mb-4">
                                            <div class="d-flex align-start font-weight-bold text-title">
                                                <span class="flex-fill">{{ element.title }}</span>
                                                <v-btn size="small" variant="text" icon="mdi-delete-outline" rounded
                                                    color="primary" class="my-n2 mr-n2"
                                                    @click.stop="agentStore.deleteCard(column, index)"></v-btn>
                                            </div>
                                            <div class="text-content">{{ element.description }}</div>
                                        </v-card>
                                    </template>
                                </vuedraggable>
                            </v-col>
                        </v-row>
                        <v-row class="ma-1">
                            <v-col>
                                <div class="d-flex align-center mb-4">
                                    <h5 class="font-weight-bold mb-0">MCP</h5>
                                    <v-spacer></v-spacer>
                                    <v-btn variant="text" rounded icon="mdi-refresh" size="small" color="primary"
                                        @click="settingStore.refreshMcpServersList()"
                                        title="Refresh server list">
                                    </v-btn>
                                    <v-btn variant="text" rounded icon="mdi-plus" size="small" color="primary"
                                        @click="settingStore.addMcpDialog = true">
                                    </v-btn>
                                </div>
                                <v-divider></v-divider>
                                
                                <!-- MCP Servers List -->
                                <div v-if="settingStore.mcpServersList.length === 0" class="text-center pa-4 text-caption text-grey">
                                    No MCP servers configured yet
                                </div>
                                
                                <v-list v-else density="compact" class="mb-4">
                                    <v-list-item v-for="server in settingStore.mcpServersList" :key="server.name"
                                        :title="server.name" class="mb-2" @dblclick="settingStore.showMcpServerConfig(server)" style="cursor: pointer;">
                                        <template v-slot:prepend>
                                            <v-icon v-if="settingStore.mcpServerStatus[server.name] === 'available'" 
                                                color="success" icon="mdi-check-circle"></v-icon>
                                            <v-icon v-else-if="settingStore.mcpServerStatus[server.name] === 'unavailable'" 
                                                color="error" icon="mdi-alert-circle"></v-icon>
                                            <v-progress-circular v-else-if="settingStore.mcpServerStatus[server.name] === 'testing'"
                                                indeterminate size="24" color="primary" class="mr-2"></v-progress-circular>
                                            <v-icon v-else color="warning" icon="mdi-help-circle"></v-icon>
                                        </template>
                                        
                                        <v-list-item-subtitle class="text-caption">
                                            {{ server.config.type === 'http' ? 
                                                (server.config.url || 'No URL') : 
                                                (server.config.command || 'No command') }}
                                        </v-list-item-subtitle>
                                        
                                        <template v-slot:append>
                                            <v-btn variant="text" size="x-small" icon="mdi-check-network" 
                                                :disabled="settingStore.mcpTestingServers.includes(server.name)"
                                                @click="settingStore.testMcpServer(server.name)"
                                                title="Test server connection">
                                            </v-btn>
                                            <v-btn variant="text" size="x-small" icon="mdi-delete" color="error"
                                                @click="settingStore.deleteMcpServer(server.name)"
                                                title="Delete server">
                                            </v-btn>
                                        </template>
                                    </v-list-item>
                                </v-list>
                                
                                <!-- Tools List from Servers -->
                                <v-data-table-server hide-default-footer hide-default-header hide-no-data disable-sort
                                    v-if="mcpStore.getServers && mcpStore.serverTools.length > 0" 
                                    :items="mcpStore.serverTools"
                                    @update:options="mcpStore.loadTools"
                                    :loading="mcpStore.loading"></v-data-table-server>
                            </v-col>
                        </v-row>

                    </v-container>
                </v-card>
            </v-dialog>

            <v-dialog v-model="agentStore.editDialog" class="dialog-card">
                <v-card>
                    <v-card-title class="pa-4 d-flex align-center">
                        <span class="flex-fill">Edit Card</span>
                        <v-btn variant="text" rounded icon="mdi-close" size="small" color="primary"
                            @click="agentStore.editDialog = false">
                        </v-btn>
                    </v-card-title>
                    <v-divider></v-divider>
                    <div class="pa-4">
                        <v-text-field class="py-2 px-1" color="primary" v-model="agentStore.card.title" label="Title"
                            variant="plain" hideDetails placeholder="Title" autofocus
                            @keyup.enter="agentStore.saveCard()"></v-text-field>
                        <v-divider></v-divider>
                        <v-textarea v-model="agentStore.card.description" class="px-2 py-1" variant="plain"
                            placeholder="Description" hide-details></v-textarea>
                        <v-card-subtitle>
                            {{ agentStore.card?.refText }}
                        </v-card-subtitle>
                    </div>
                    <v-divider></v-divider>
                    <v-card-actions class="px-4 mt-4">
                        <v-file-input prepend-icon="" prepend-inner-icon="mdi-upload" class="mr-2" variant="outlined"
                            v-model="agentStore.card.refFile" label="Reference File" accept=".docx, .md, .txt"
                            single-line></v-file-input>
                        <v-spacer></v-spacer>
                        <v-btn variant="outlined" @click="agentStore.editDialog = false">Cancel</v-btn>
                        <v-btn class="ml-5" variant="flat" color="primary" @click="agentStore.saveCard()">Save</v-btn>
                    </v-card-actions>
                </v-card>
            </v-dialog>

            <!-- MCP Server Config Viewer Dialog -->
            <v-dialog v-model="settingStore.mcpConfigViewerDialog" max-width="800" class="dialog-card">
                <v-card v-if="settingStore.mcpConfigViewerServer" prepend-icon="mdi-code-json" :title="'MCP Server Config - ' + settingStore.mcpConfigViewerServer.name">
                    <v-divider></v-divider>
                    <v-card-text class="pa-4">
                        <div class="d-flex align-center mb-3">
                            <span class="text-subtitle2 font-weight-bold">Configuration:</span>
                            <v-spacer></v-spacer>
                            <v-btn size="x-small" icon="mdi-content-copy" variant="text" color="primary"
                                @click="navigator.clipboard.writeText(JSON.stringify(settingStore.mcpConfigViewerServer.config, null, 2))"
                                title="Copy to clipboard">
                            </v-btn>
                        </div>
                        <v-sheet class="pa-3 bg-surface-variant rounded" style="font-family: monospace; font-size: 12px; overflow-x: auto; max-height: 500px; overflow-y: auto;">
                            <pre>{{ JSON.stringify(settingStore.mcpConfigViewerServer.config, null, 2) }}</pre>
                        </v-sheet>
                    </v-card-text>
                    <v-divider></v-divider>
                    <v-card-actions>
                        <v-spacer></v-spacer>
                        <v-btn variant="outlined" @click="settingStore.mcpConfigViewerDialog = false">Close</v-btn>
                    </v-card-actions>
                </v-card>
            </v-dialog>

            <!-- Add MCP Server Dialog -->
            <v-dialog v-model="settingStore.addMcpDialog" max-width="700" class="dialog-card">
                <v-card prepend-icon="mdi-plus-circle" title="Add MCP Server">
                    <v-divider></v-divider>
                    <v-card-text>
                        <div class="pa-4">
                            <p class="text-caption text-grey mb-3">Paste your MCP configuration JSON and we'll extract the servers for you:</p>
                            <v-textarea class="mb-4" density='compact' color="primary" variant="outlined"
                                v-model="settingStore.mcpJsonConfig" 
                                label='Paste JSON (e.g., {"mcpServers":{"playwright":{"url":"http://..."} or {"command":"..."}}})'
                                rows="10" auto-grow clearable hide-details></v-textarea>
                            
                            <v-btn variant="flat" color="primary" class="mb-4" @click="settingStore.parseAndShowMcpServers()">
                                <v-icon start>mdi-magnify</v-icon>Extract Servers
                            </v-btn>
                            
                            <!-- Extracted Servers List -->
                            <div v-if="settingStore.extractedMcpServers.length > 0" class="mb-4">
                                <p class="text-subtitle2 mb-2">Found {{ settingStore.extractedMcpServers.length }} MCP Server(s):</p>
                                <v-checkbox v-for="(server, idx) in settingStore.extractedMcpServers" :key="idx"
                                    v-model="settingStore.selectedMcpServers" :value="idx"
                                    class="mb-2" hide-details>
                                    <template #label>
                                        <span class="font-weight-bold">{{ server.name }}</span>
                                        <span class="text-caption text-grey ml-2">
                                            <v-icon size="small" :icon="server.type === 'http' ? 'mdi-cloud' : 'mdi-console'"></v-icon>
                                            {{ server.type === 'http' ? server.url : server.command }}
                                            {{ server.args ? `(${server.args.length} args)` : '' }}
                                        </span>
                                    </template>
                                </v-checkbox>
                            </div>
                            
                            <v-alert v-if="settingStore.mcpJsonError" type="error" class="mb-4" closable @input="settingStore.mcpJsonError = ''">
                                {{ settingStore.mcpJsonError }}
                            </v-alert>
                        </div>
                    </v-card-text>

                    <v-card-actions>
                        <v-spacer></v-spacer>
                        <v-btn variant="outlined" @click="settingStore.addMcpDialog = false">Cancel</v-btn>
                        <v-btn variant="flat" color="primary" 
                            :disabled="settingStore.selectedMcpServers.length === 0"
                            @click="settingStore.addExtractedMcpServers()">
                            Add Selected ({{ settingStore.selectedMcpServers.length }})
                        </v-btn>
                    </v-card-actions>
                </v-card>
            </v-dialog>

            <!-- <div v-if="settingStore.toolboxShow !== true" class="toolbox-button"
                @click="settingStore.toolboxShow = true">
                <v-icon class="rotation text-white">mdi-tools</v-icon>
            </div>
            <v-card v-else elevation="10" class="d-flex flex-column toolbox">
                <v-btn @click="resetALL()" variant="text" size="45">
                    <v-icon size="25" color="error">mdi-store-remove</v-icon>
                    <v-tooltip activator="parent" location="left" text="Reset All Config"></v-tooltip>
                </v-btn>
                <v-btn @click="settingStore.toolboxShow = false" variant="text" size="45" color="error">
                    <v-icon size="25">mdi-close</v-icon>
                    <v-tooltip activator="parent" location="left" text="Close Toolbox"></v-tooltip>
                </v-btn>
            </v-card> -->
        </v-app>
    </div>

    <template id="tuui-chat-box-template">
        <div v-for="group in groupMessages">
            <div v-if="group.group === 'user'">
                <div class="px-2 py-5 chat-message">
                    <div class="message">
                        <v-avatar :size=size class="mt-3 mr-3 mr-lg-6" color="primary" icon="mdi-account-circle">
                        </v-avatar>
                        <tuui-chat-card class="gradient text-pre-wrap" :index="group.index" :messages="messages"
                            :show-modify="true">
                            <template v-slot:default="{ showmodify }">
                                <v-card-text v-if="Array.isArray(group.message.content)" class="md-preview">
                                    <div v-for="(item, index) in group.message.content" :key="index">
                                        <tuui-img-dialog v-if="item.type=='image_url'"
                                            :src="item.image_url.url"></tuui-img-dialog>
                                        <v-textarea class="conversation-area" variant="plain" density='compact'
                                            auto-grow :counter="showmodify" :hide-details="!showmodify" rows="1"
                                            :readonly="!showmodify" v-model="item.text"></v-textarea>
                                    </div>
                                </v-card-text>
                                <v-card-text v-else class="md-preview pt-1">
                                    <v-textarea class="conversation-area" variant="plain" density='compact' auto-grow
                                        rows="1" :readonly="!showmodify" :counter="showmodify"
                                        :hide-details="!showmodify" v-model="group.message.content"></v-textarea>
                                </v-card-text>
                            </template>
                        </tuui-chat-card>
                    </div>
                </div>
            </div>
            <div v-if="group.group === 'assistant'">
                <div class="px-2 py-5 chat-message">
                    <div class="message">
                        <v-avatar :size=size class="mt-3 mr-3 mr-lg-6" color="teal" icon="mdi-lightning-bolt-circle">
                        </v-avatar>
                        <tuui-chat-card :index="group.index" :messages="messages" :show-content="true">
                            <template v-slot:default="{ showcontent }">
                                <v-card-text v-if="group.message.reasoning_content" class="md-preview pt-1">
                                    <v-textarea class="conversation-area text-disabled font-italic" variant="plain"
                                        density='compact' auto-grow hide-details rows="1" readonly
                                        v-model="group.message.reasoning_content"></v-textarea>
                                </v-card-text>
                                <v-card-text v-if="showcontent" class="md-preview pt-1">
                                    <v-textarea class="conversation-area" variant="plain" density='compact' auto-grow
                                        hide-details rows="1" readonly v-model="group.message.content"></v-textarea>
                                </v-card-text>
                                <v-card-text v-else class="md-preview px-4 py-3">
                                    <md-preview :model-value="group.message.content"
                                        :language="language == 'zhHans' ? 'zh-CN' : 'en-US'" :code-foldable="true"
                                        auto-fold-threshold="Infinity"></md-preview>
                                </v-card-text>
                            </template>
                        </tuui-chat-card>
                    </div>
                </div>
            </div>
            <div v-if="group.group === 'tool'">
                <div class="px-2 py-5 chat-message">
                    <div class="message">
                        <v-avatar :size=size class="mt-3 mr-3 mr-lg-6" color="brown" icon="mdi-swap-vertical-circle">
                        </v-avatar>
                        <tuui-chat-card :messages="messages" :show-copy="false" :index="group.index"
                            :range="group.messages.length">
                            <v-tabs v-model="dialogs[group.tab]" :items="group.messages" show-arrows>
                                <template v-slot:tab="{ item }">
                                    <v-tab :text="item.index" :key="item.index" :value="item.index">
                                        <v-icon v-if="item.role == 'tool'" icon="mdi-arrow-left-bold-circle"
                                            color="primary"></v-icon>
                                        <v-icon v-if="item.role == 'assistant'" icon="mdi-arrow-right-bold-circle"
                                            color="teal"></v-icon>
                                    </v-tab>
                                </template>
                                <template v-slot:item="{ item }">
                                    <v-tabs-window-item :key="item.index" :value="item.index">
                                        <v-card class="mt-1" variant="flat" v-if="item.role == 'tool'">
                                            <v-card-item prepend-icon="mdi-chevron-left">
                                                <v-card-subtitle>
                                                    {{item.tool_call_id}}
                                                </v-card-subtitle>
                                            </v-card-item>
                                            <v-card-text v-if="Array.isArray(item.content)"
                                                v-for="content in item.content">
                                                {{content.text}}
                                            </v-card-text>
                                            <v-card-text v-else>
                                                {{item.content}}
                                            </v-card-text>
                                        </v-card>
                                        <v-card class="mt-1" variant="flat" v-if="item.role == 'assistant'">
                                            <v-card-text v-if="item.reasoning_content" class="font-weight-bold">
                                                {{ item.reasoning_content }}
                                            </v-card-text>
                                            <v-card-text v-if="item.content" class="font-weight-bold">
                                                {{ item.content }}
                                            </v-card-text>
                                            <div v-for="content in item.tool_calls">
                                                <v-card-item prepend-icon="mdi-chevron-right">
                                                    <v-card-subtitle>
                                                        {{content.id}}
                                                    </v-card-subtitle>
                                                </v-card-item>
                                                <v-card-text>
                                                    {{content.function.name}}({{content.function.arguments }})
                                                </v-card-text>
                                            </div>
                                        </v-card>
                                    </v-tabs-window-item>
                                </template>
                            </v-tabs>
                        </tuui-chat-card>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <template id="tuui-img-dialog-template">
        <v-dialog>
            <template v-slot:activator="{ props: activatorProps }">
                <div>
                    <v-img class="history-images mb-3" contain position="left" min-width="80px" min-height="80px"
                        width="100%" height="100%" max-width="30vw" max-height="30vh" v-bind="activatorProps"
                        :src="src"></v-img>
                </div>
            </template>
            <template v-slot:default="{ isActive }">
                <v-img @click="isActive.value = false" contain width="80vw" height="80vh" max-width="100%"
                    max-height="100%" :src="src"></v-img>
            </template>
        </v-dialog>
    </template>

    <template id="tuui-chat-card-template">
        <v-hover open-delay="100">
            <template v-slot:default="{ isHovering, props }">
                <v-card v-bind="props" :elevation="isHovering ? 4 : 2" width="100vw" max-width="100%">
                    <slot :showcontent="showcontent" :showmodify="showmodify"></slot>
                    <v-expand-transition>
                        <div v-if="isHovering">
                            <v-divider></v-divider>
                            <v-card-actions>
                                <v-btn v-if="showCopy" color="primary" icon="mdi-content-copy" size="x-small"
                                    variant="plain" @click="copyToClipboard(messages[index])"></v-btn>
                                <v-btn v-if="showModify" color="primary"
                                    :icon=" showmodify ? 'mdi-check-bold' : 'mdi-lead-pencil'" size="x-small"
                                    variant="plain" @click="showmodify = !showmodify" v-bind="showmodify"></v-btn>
                                <v-btn v-if="showContent" color="primary"
                                    :icon=" showcontent ? 'mdi-eye-remove' : 'mdi-eye'" size="x-small" variant="plain"
                                    @click="showcontent = !showcontent" v-bind="showcontent"></v-btn>
                                <v-spacer></v-spacer>
                                <v-btn v-if="showReduce && index > 0" color="error" icon="mdi-format-align-top"
                                    size="x-small" variant="plain" @click="messages.splice(0, index)"></v-btn>
                                <v-btn v-if="showDelete" color="error" icon="mdi-delete-off-outline" size="x-small"
                                    variant="plain" @click="messages.splice(index, range)"></v-btn>
                            </v-card-actions>
                        </div>
                    </v-expand-transition>
                </v-card>
            </template>
        </v-hover>
    </template>

    <script lang="ts" setup>
        const { createApp, ref, reactive, computed, onMounted, watch, nextTick, axios, defineProps, defineComponent } = Vue
        const { createVuetify } = Vuetify
        const { createPinia, defineStore, storeToRefs } = Pinia
        const { createI18n, useI18n } = VueI18n
        const { en, it, ja, sv, zhHans } = 'vuetify/locale'

        const useMcpStore = defineStore("mcpStore", {
            state: () => ({
                serverTools: [],
                loading: true,
                mcpServers: {},
            }),

            getters: {
                getServers: (state) => {
                    console.log('MCP:', Object.keys(state.mcpServers))
                    return state.mcpServers;
                },
            },

            actions: {
                updateServers: async function() {
                    try {
                        this.mcpServers = await window.getServers();
                        console.log('Updated MCP servers:', Object.keys(this.mcpServers));
                    } catch (error) {
                        console.error('Failed to update MCP servers:', error);
                        this.mcpServers = {};
                    }
                },
                listServerResources: async function () {
                    // 
                    await this.updateServers();
                    
                    const mcpServers = this.getServers
                    const mcpKeys = Object.keys(mcpServers)
                    const mcpResources = []
                    for (const key of mcpKeys) {
                        const resources = mcpServers[key]?.resources
                        if (resources) {
                            mcpResources.push({
                                name: key,
                                list: resources.list,
                                templatesList: resources['templates/list']
                            })
                        }
                    }
                    return mcpResources
                },
                loadTools: function () {
                    this.loading = true
                    try {
                        this.listTools().then((tools) => {
                            this.serverTools = tools.map(tool => {
                                return {
                                    name: tool.function.name,
                                    description: tool.function.description
                                }
                            }
                            )
                            return
                        })
                    } catch (error) {
                        console.error('Failed to load tools:', error);
                    } finally {
                        this.loading = false;
                    }

                },
                listTools: async function () {
                    // 
                    await this.updateServers();
                    
                    const mcpServers = this.getServers
                    console.log(`List MCP Servers: ${Object.keys(mcpServers)}`)
                    if (!mcpServers) {
                        console.warn('No MCP servers available');
                        return null
                    }
                    const mcpKeys = Object.keys(mcpServers)
                    console.log(`[listTools] Found ${mcpKeys.length} servers: ${mcpKeys.join(', ')}`);
                    
                    const mcpTools = []
                    for (const key of mcpKeys) {
                        const server = mcpServers[key];
                        const toolsListFunction = server?.tools?.list;
                        
                        console.log(`[listTools] Processing server "${key}":`, {
                            has_tools: !!server?.tools,
                            is_function: typeof toolsListFunction === 'function',
                            toolsListFunction: toolsListFunction?.toString?.()?.substring(0, 100)
                        });
                        
                        if (typeof toolsListFunction === 'function') {
                            try {
                                const tools = await toolsListFunction();
                                console.log(`[listTools] Server "${key}" returned tools:`, tools);
                                
                                if (tools && Array.isArray(tools.tools)) {
                                    console.log(`[listTools] Server "${key}" has ${tools.tools.length} tools`);
                                    for (const tool of tools.tools) {
                                        mcpTools.push({
                                            type: 'function',
                                            function: {
                                                name: tool.name,
                                                description: tool.description,
                                                parameters: tool.inputSchema,
                                            }
                                        });
                                    }
                                } else {
                                    console.warn(`[listTools] Server "${key}" returned invalid tools format:`, tools);
                                }
                            } catch (error) {
                                console.error(`[listTools] Error calling tools.list() on server "${key}":`, error);
                            }
                        } else {
                            console.warn(`[listTools] Server "${key}" tools.list is not a function. Type: ${typeof toolsListFunction}, Value: ${toolsListFunction}`);
                        }
                    }
                    
                    console.log(`[listTools] Total tools collected: ${mcpTools.length}`, mcpTools);
                    return mcpTools
                },
                getTool: async function (tool_name) {
                    // 
                    await this.updateServers();
                    
                    const mcpServers = this.getServers;
                    console.log(`Get MCP Servers: ${Object.keys(mcpServers)}`)
                    const mcpKeys = Object.keys(mcpServers);
                    const result = await Promise.any(mcpKeys.map(async (key) => {
                        const toolsListFunction = mcpServers[key]?.tools?.list;
                        if (typeof toolsListFunction === 'function') {
                            const tools = await toolsListFunction();
                            if (tools && Array.isArray(tools.tools)) {
                                const foundTool = tools.tools.find(tool => tool.name === tool_name);
                                if (foundTool) {
                                    return {
                                        server: key,
                                        tool: foundTool
                                    };
                                }
                            }
                        }
                        throw new Error(`Tool ${tool_name} not found on server ${key}`);
                    }));

                    return result;
                },
                callTool: async function (tool_name, tool_args) {
                    // 
                    await this.updateServers();
                    
                    const tool = await this.getTool(tool_name)
                    if (!tool) {
                        return this.packReturn(`Tool name '${tool_name}' not found`)
                    }

                    let tool_arguments

                    try {
                        tool_arguments = JSON.parse(tool_args)
                    } catch (e) {
                        return this.packReturn(`Arguments JSON parse error: '${e}'`)
                    }

                    const params = {
                        name: tool_name,
                        arguments: tool_arguments
                    }

                    const result = await this.getServers[tool.server].tools.call(params)
                    return result
                },
                convertItem: function (item) {
                    if (item.type === "text") {
                        return item;
                    } else if (item.type === "image") {
                        const imageUrl = `data:${item.mimeType};base64,${item.data}`;
                        return {
                            type: 'image_url',
                            image_url: { url: imageUrl }
                        };
                    }
                },
                packReturn: (string) => {
                    return {
                        content: [{
                            type: 'text',
                            text: string
                        }]
                    }
                },
                addMcpServer: function (settingStore) {
                    // Validate required fields
                    if (!settingStore.mcpServerName) {
                        console.error('Server name is required');
                        alert('Server name is required');
                        return;
                    }

                    try {
                        // Parse the configuration JSON if provided
                        let config = {};
                        if (settingStore.mcpServerConfig) {
                            config = JSON.parse(settingStore.mcpServerConfig);
                        }

                        let serverConfig = {
                            type: settingStore.mcpServerType,
                            ...config
                        };

                        // Handle different server types
                        if (settingStore.mcpServerType === 'http') {
                            // Validate HTTP/SSE server
                            if (!settingStore.mcpServerUrl) {
                                console.error('Server URL is required for HTTP/SSE servers');
                                alert('Server URL is required for HTTP/SSE servers');
                                return;
                            }

                            serverConfig = {
                                type: 'http',
                                url: settingStore.mcpServerUrl,
                                port: settingStore.mcpServerPort ? parseInt(settingStore.mcpServerPort) : undefined,
                                transport: 'sse', // Default to SSE, can be overridden in config
                                ...config
                            };
                        } else if (settingStore.mcpServerType === 'local') {
                            // Validate local server
                            if (!settingStore.mcpServerCommand) {
                                console.error('Command is required for local servers');
                                alert('Command is required for local servers');
                                return;
                            }

                            const args = settingStore.mcpServerArgs
                                ? settingStore.mcpServerArgs.split('\n').filter(arg => arg.trim())
                                : [];

                            serverConfig = {
                                type: 'local',
                                command: settingStore.mcpServerCommand,
                                args: args.length > 0 ? args : undefined,
                                ...config
                            };
                        }

                        // Store in sessionStorage as the source of truth for dynamically added servers
                        // window.mcpServers is a read-only proxy from contextBridge, so we can't modify it directly
                        const dynamicServers = JSON.parse(sessionStorage.getItem('dynamicMcpServers') || '{}');
                        dynamicServers[settingStore.mcpServerName] = serverConfig;
                        sessionStorage.setItem('dynamicMcpServers', JSON.stringify(dynamicServers));

                        console.log('MCP Server configuration added:', settingStore.mcpServerName, serverConfig);
                        console.log('Stored in sessionStorage. Current dynamic servers:', Object.keys(dynamicServers));

                        // Show success message
                        console.log(`Successfully added ${settingStore.mcpServerType} MCP server: ${settingStore.mcpServerName}`);

                    } catch (error) {
                        console.error('Failed to add MCP server:', error);
                        alert('Failed to add MCP server: ' + error.message);
                    }
                },
                getServersList: async function () {
                    // Get real-time server list from main process via IPC
                    try {
                        const clients = await window.listClients();
                        console.log('getServersList called, clients from main:', clients);
                        
                        // Convert clients to server list format
                        const serverList = [];
                        
                        if (Array.isArray(clients)) {
                            // clients is an array of client objects from list-clients
                            for (const client of clients) {
                                serverList.push({
                                    name: client.name,
                                    config: {
                                        type: client.type || 'local',
                                        url: client.url || undefined,
                                        command: client.command || undefined,
                                        args: client.args || undefined,
                                        message: client.message || undefined
                                    },
                                    status: 'unknown'
                                });
                            }
                        } else if (typeof clients === 'object' && clients !== null) {
                            // clients is an object map of servers
                            for (const [name, serverConfig] of Object.entries(clients)) {
                                serverList.push({
                                    name: name,
                                    config: serverConfig,
                                    status: 'unknown'
                                });
                            }
                        }
                        
                        console.log('Returning server list:', serverList);
                        return serverList;
                    } catch (error) {
                        console.error('Error fetching server list:', error);
                        return [];
                    }
                },
                testServer: async function (serverName) {
                    const mcpServers = this.getServers;
                    if (!mcpServers || !mcpServers[serverName]) {
                        console.error(`Server ${serverName} not found`);
                        return { available: false, message: 'Server not found' };
                    }

                    const serverConfig = mcpServers[serverName];
                    console.log(mcpServers);
                    console.log(serverName);
                    try {
                        // MCP
                        const toolsListFunction = serverConfig.tools?.list;
                        if (typeof toolsListFunction === 'function') {
                            try {
                                const tools = await toolsListFunction();
                                if (tools && Array.isArray(tools.tools)) {
                                    return { available: true, message: `Local server available with ${tools.tools.length} tools` };
                                }
                            } catch (err) {
                                console.log(`Local server test failed: ${err.message}`);
                            }
                        }
                        
                        // HTTP
                        const url = serverConfig.url;
                        console.log(serverConfig)
                        if (url) {
                            try {
                                const response = await fetch(url, { 
                                    method: 'HEAD',
                                    timeout: 5000
                                });
                                console.log(response);
                                if (response.ok || response.status === 404) {
                                    return { available: true, message: 'HTTP server is reachable' };
                                } else {
                                    return { available: false, message: `HTTP server returned status ${response.status}` };
                                }
                            } catch (err) {
                                console.log(`HTTP server test failed: ${err.message}`);
                            }
                        }
                        
                        // 
                        return { available: false, message: 'Server is not available (both local and HTTP tests failed)' };
                    } catch (error) {
                        console.error(`Error testing server ${serverName}:`, error);
                        return { available: false, message: `Error: ${error.message}` };
                    }
                },
                deleteServer: function (serverName) {
                    const mcpServers = this.getServers;
                    if (mcpServers && mcpServers[serverName]) {
                        delete mcpServers[serverName];
                        console.log(`Server ${serverName} deleted`);
                        this.loadTools();
                        return true;
                    }
                    return false;
                }
            },
        });

        const useAgentStore = defineStore("agentStore", {
            state: () => ({
                card: null,
                columns: [],
                editDialog: false,
            }),

            persist: {
                enabled: true,
                strategies: [{ storage: sessionStorage }],
            },

            getters: {
                getDragOption: () => {
                    return {
                        animation: 200,
                        group: "task",
                        disabled: false,
                        ghostClass: "ghost",
                    };
                },

            },

            actions: {
                addCard(column) {
                    const { addTitle, key } = column;
                    if (!addTitle) return;
                    let newCard = {
                        id: "_" + Math.random().toString(36).substring(2, 11),
                        state: key,
                        title: addTitle,
                        description: "",
                        refFile: null,
                        refText: "",
                        order: -1,
                    };
                    column.cards.unshift(newCard);
                    column.addTitle = "";
                    column.isAddVisible = false;
                },
                deleteCard(column, index) {
                    column.cards.splice(index, 1);
                },
                editCard(card) {
                    this.card = { ...card }
                    this.editDialog = true;
                },
                saveCard() {
                    const editCard = this.card
                    if (editCard) {
                        let foundCard = this.columns
                            .flatMap(column => column.cards)
                            .find(card => card.id === this.card.id);
                        if (foundCard) {
                            foundCard.title = editCard.title;
                            foundCard.refText = editCard.refText
                            foundCard.refFile = editCard.refFile
                            foundCard.description = editCard.description;
                            this.editDialog = false;
                        }
                    }

                },
                promptMessage(conversation) {

                    const result = this.columns[0].cards
                        .filter(
                            (item) => {
                                return item.description !== "" || item.refText !== "";
                            }
                        )
                        .map(item => (
                            item.refText ? `${item.description}\n###\n${item.refText}\n###` : item.description
                        ))
                        .join('\n\n');

                    if (result) {
                        return [{ content: result, role: "system" }, ...conversation]
                    } else {
                        return [...conversation]
                    }
                    return [...conversation]

                },
                initAgent() {
                    this.$reset();
                    const states = ref(["PROMPT", "BACKUP"]);
                    const changeState = (e, colIndex) => {
                        console.log(e)
                        if (e.added || e.moved) {
                            const column = this.columns[colIndex];
                            const state = column.key;
                            for (let i = 0; i < column.cards.length; i++) {
                                column.cards[i].order = i;
                                column.cards[i].state = state;
                            }
                        }
                    };

                    states.value.forEach((state, index) => {
                        this.columns.push({
                            key: state,
                            cards: [],
                            isAddVisible: false,
                            callback: (e) => changeState(e, index),
                        });
                    });

                    this.parseCards([
                        {
                            id: 1,
                            title: "Prompt 1",
                            description: "",
                            state: "PROMPT",
                        },
                        // {
                        //     id: 2,
                        //     title: "Agent 1",
                        //     description: "TODO",
                        //     state: "BACKUP",
                        // },

                    ])

                },

                parseCards(cards) {
                    if (!cards) return this.columns.map((column) => (column.cards = []));

                    this.columns.forEach((column) => {
                        column.cards = cards
                            .filter((card) => card.state === column.key)
                            .sort((a, b) => (a.order < b.order ? -1 : 0));
                    });
                },

            },

        });

        const useSettingStore = defineStore("settingStore", {
            state: () => ({
                inputRow: 1,
                avatarSize: 24,
                configDialog: false,
                configHistory: false,

                agentDialog: false,

                apiKeyShow: false,

                toolboxShow: false,
                fontStatus: false,
                
                // MCP Server configuration
                addMcpDialog: false,
                mcpServerName: '',
                mcpServerType: 'local', // http, or local
                mcpServerUrl: '',
                mcpServerPort: '',
                mcpServerCommand: '', // For local MCP servers
                mcpServerArgs: '', // For local MCP servers
                mcpServerConfig: '',
                
                // Quick mode - JSON parsing
                mcpJsonConfig: '',
                mcpJsonError: '',
                extractedMcpServers: [], // Array of {name, command, args}
                selectedMcpServers: [], // Array of indices of selected servers
                
                // MCP Server list management
                mcpServersList: [], // List of configured servers
                mcpServerStatus: {}, // {serverName: 'available'|'unavailable'|'testing'|'unknown'}
                mcpTestingServers: [], // Array of servers currently being tested
                
                // MCP Server config viewer
                mcpConfigViewerDialog: false,
                mcpConfigViewerServer: null, // The server being viewed
            }),
            actions: {
                initDialog() {
                    this.apiKeyShow = false; // hide api key
                    this.configDialog = true;
                },
                setInputRow(int, timeout) {
                    setTimeout(() => {
                        this.inputRow = int
                    }, timeout);
                },
                resetMcpFields() {
                    this.mcpServerName = '';
                    this.mcpServerType = 'local';
                    this.mcpServerUrl = '';
                    this.mcpServerPort = '';
                    this.mcpServerCommand = '';
                    this.mcpServerArgs = '';
                    this.mcpServerConfig = '';
                },
                parseAndShowMcpServers() {
                    this.mcpJsonError = '';
                    this.extractedMcpServers = [];
                    this.selectedMcpServers = [];

                    if (!this.mcpJsonConfig.trim()) {
                        this.mcpJsonError = 'Please paste the JSON configuration';
                        return;
                    }

                    try {
                        const jsonData = JSON.parse(this.mcpJsonConfig);
                        
                        // Support both direct mcpServers object and wrapped format
                        let servers = jsonData.mcpServers || jsonData;
                        
                        if (!servers || typeof servers !== 'object') {
                            this.mcpJsonError = 'No valid MCP servers found in the JSON';
                            return;
                        }

                        // Extract all servers (both local and remote)
                        for (const [serverName, serverConfig] of Object.entries(servers)) {
                            if (serverConfig && typeof serverConfig === 'object') {
                                // Check if it's a remote HTTP/SSE server
                                if (serverConfig.url) {
                                    this.extractedMcpServers.push({
                                        name: serverName,
                                        type: 'http',
                                        url: serverConfig.url,
                                        config: serverConfig // Store full config for later use
                                    });
                                }
                                // Check if it's a local command server
                                else if (serverConfig.command) {
                                    const args = serverConfig.args || [];
                                    this.extractedMcpServers.push({
                                        name: serverName,
                                        type: 'local',
                                        command: serverConfig.command,
                                        args: Array.isArray(args) ? args : [args],
                                        config: serverConfig // Store full config for later use
                                    });
                                }
                            }
                        }

                        if (this.extractedMcpServers.length === 0) {
                            this.mcpJsonError = 'No valid MCP servers found (each server must have a "url" or "command" property)';
                            return;
                        }

                        // Auto-select all servers
                        this.selectedMcpServers = this.extractedMcpServers.map((_, idx) => idx);

                    } catch (error) {
                        this.mcpJsonError = `Invalid JSON: ${error.message}`;
                    }
                },
                addExtractedMcpServers() {
                    const successCount = this.selectedMcpServers.length;
                    const serversToInitialize = [];
                    
                    for (const idx of this.selectedMcpServers) {
                        const server = this.extractedMcpServers[idx];
                        if (server) {
                            // Populate fields with extracted server data
                            this.mcpServerName = server.name;
                            this.mcpServerType = server.type; // 'http' or 'local'
                            
                            if (server.type === 'http') {
                                // Remote HTTP/SSE server
                                this.mcpServerUrl = server.url;
                                this.mcpServerPort = '';
                                this.mcpServerCommand = '';
                                this.mcpServerArgs = '';
                                
                                // Store any additional config
                                const { url, ...additionalConfig } = server.config;
                                if (Object.keys(additionalConfig).length > 0) {
                                    this.mcpServerConfig = JSON.stringify(additionalConfig, null, 2);
                                } else {
                                    this.mcpServerConfig = '';
                                }
                            } else {
                                // Local command server
                                this.mcpServerUrl = '';
                                this.mcpServerPort = '';
                                this.mcpServerCommand = server.command;
                                this.mcpServerArgs = server.args.join('\n');
                                
                                // Store any additional config
                                const { command, args, ...additionalConfig } = server.config;
                                if (Object.keys(additionalConfig).length > 0) {
                                    this.mcpServerConfig = JSON.stringify(additionalConfig, null, 2);
                                } else {
                                    this.mcpServerConfig = '';
                                }
                            }

                            // Add the server using the MCP store
                            useMcpStore().addMcpServer(this);
                            
                            // Collect server info for initialization - only send serializable data
                            // Deep clone to ensure no circular references
                            const serializableConfig = JSON.parse(JSON.stringify(server.config));
                            // Ensure type is included in the config
                            serializableConfig.type = server.type;
                            serversToInitialize.push({
                                name: server.name,
                                config: serializableConfig
                            });
                        }
                    }

                    // Show success message
                    console.log(`Added ${successCount} MCP server(s)`);

                    // Reset quick mode
                    this.mcpJsonConfig = '';
                    this.mcpJsonError = '';
                    this.extractedMcpServers = [];
                    this.selectedMcpServers = [];
                    
                    // Reset form fields
                    this.resetMcpFields();
                    
                    // Close dialog
                    this.addMcpDialog = false;
                    
                    // Initialize servers dynamically and refresh list
                    this.initializeServersAndRefresh(serversToInitialize);
                },

                async initializeServersAndRefresh(serversToInitialize) {
                    try {
                        console.log('Initializing servers dynamically:', serversToInitialize);
                        const snackbarStore = useSnackbarStore();
                        
                        // Track how many servers were actually initialized
                        let successCount = 0;
                        let skipCount = 0;
                        
                        // Initialize each server in the main process
                        for (const serverInfo of serversToInitialize) {
                            try {
                                const result = await window.initializeMcpServer(serverInfo.name, serverInfo.config);
                                if (result.success) {
                                    console.log(`Server ${serverInfo.name} initialized successfully`, result);
                                    successCount++;
                                } else {
                                    // Check if it's a "already exists" error - that's okay, just skip
                                    if (result.message && result.message.includes('already exists')) {
                                        console.log(`Server ${serverInfo.name} already initialized, skipping`);
                                        skipCount++;
                                    } else {
                                        console.error(`Failed to initialize server ${serverInfo.name}:`, result.message);
                                    }
                                }
                            } catch (error) {
                                console.error(`Error initializing server ${serverInfo.name}:`, error);
                            }
                        }
                        
                        // If there were servers to initialize (either new or already existing)
                        if (successCount > 0 || skipCount > 0) {
                            // Show a brief success message and then reload
                            console.log(`Initialization complete: ${successCount} new, ${skipCount} already existed. Reloading page to activate...`);
                            let message = `Successfully registered ${successCount} MCP server(s)!`;
                            if (skipCount > 0) {
                                message = `${successCount} new and ${skipCount} existing MCP server(s) ready.`;
                            }
                            message += ' Reloading to activate...';
                            snackbarStore.showSuccessMessage(message);
                            
                            // Add a small delay to let the snackbar display, then reload
                            setTimeout(() => {
                                window.location.reload();
                            }, 1500);
                        } else {
                            snackbarStore.showWarningMessage('No servers to initialize');
                        }
                    } catch (error) {
                        console.error('Error during server initialization:', error);
                        snackbarStore.showErrorMessage(`Error initializing servers: ${error.message}`);
                    }
                },
                refreshMcpServersList() {
                    // Refresh server list - now async
                    useMcpStore().getServersList().then(serversList => {
                        // Update the list reactively
                        this.mcpServersList = [...serversList];
                        
                        // Initialize status for new servers
                        for (const server of this.mcpServersList) {
                            if (!this.mcpServerStatus.hasOwnProperty(server.name)) {
                                // Vue 3: direct assignment works fine
                                this.mcpServerStatus[server.name] = 'unknown';
                            }
                        }
                        
                        console.log('MCP Servers List Updated:', this.mcpServersList);
                        
                        // Also update mcpStore's servers
                        const mcpStore = useMcpStore();
                        mcpStore.updateServers();
                    }).catch(error => {
                        console.error('Error refreshing MCP servers list:', error);
                    });
                },
                showMcpServerConfig(server) {
                    this.mcpConfigViewerServer = server;
                    this.mcpConfigViewerDialog = true;
                },
                testMcpServer(serverName) {
                    if (this.mcpTestingServers.includes(serverName)) {
                        return; // Already testing
                    }

                    this.mcpTestingServers.push(serverName);
                    this.mcpServerStatus[serverName] = 'testing';

                    useMcpStore().testServer(serverName).then(result => {
                        this.mcpServerStatus[serverName] = result.available ? 'available' : 'unavailable';
                        this.mcpTestingServers = this.mcpTestingServers.filter(s => s !== serverName);
                        
                        if (result.message) {
                            console.log(`Server ${serverName}: ${result.message}`);
                        }
                    }).catch(err => {
                        this.mcpServerStatus[serverName] = 'unavailable';
                        this.mcpTestingServers = this.mcpTestingServers.filter(s => s !== serverName);
                        console.error(`Error testing server ${serverName}:`, err);
                    });
                },
                deleteMcpServer(serverName) {
                    if (confirm(`Are you sure you want to delete the MCP server "${serverName}"?`)) {
                        // Delete from window.mcpServers
                        useMcpStore().deleteServer(serverName);
                        
                        // Delete from sessionStorage dynamic servers
                        const dynamicServers = JSON.parse(sessionStorage.getItem('dynamicMcpServers') || '{}');
                        delete dynamicServers[serverName];
                        sessionStorage.setItem('dynamicMcpServers', JSON.stringify(dynamicServers));
                        
                        // Delete from config file via IPC
                        window.deleteMcpServer(serverName).then(result => {
                            if (result.success) {
                                console.log(`Server ${serverName} deleted successfully:`, result.message);
                            } else {
                                console.error(`Failed to delete server ${serverName}:`, result.message);
                            }
                        }).catch(error => {
                            console.error(`Error deleting server ${serverName}:`, error);
                        });
                        
                        // Refresh UI
                        this.refreshMcpServersList();
                        delete this.mcpServerStatus[serverName];
                    }
                }

            },
        });

        const useResourceStore = defineStore("resourceStore", {
            state: () => ({
                resourceDialog: false,
                tab: null,

                resourceList: [],
                resourceTemplatesList: [],

                loadingTemplates: false,
                loadingResources: false,
            }),
            actions: {
                loadTemplates: function (resource_function) {
                    this.loadingTemplates = true
                    try {
                        resource_function().then((result) => {
                            console.log(result)
                            this.resourceTemplatesList = result.resourceTemplates
                            return
                        })
                    } catch (error) {
                        console.error('Failed to load resource templates:', error);
                    } finally {
                        this.loadingTemplates = false;
                    }

                },
                loadResources: function (resource_function) {
                    this.loadingResources = true
                    try {
                        resource_function().then((result) => {
                            console.log(result)
                            this.resourceList = result.resources
                            return
                        })
                    } catch (error) {
                        console.error('Failed to load resources:', error);
                    } finally {
                        this.loadingResources = false;
                    }

                },
            },
        });

        const useSnackbarStore = defineStore("snackbarStore", {
            state: () => ({
                isShow: false,
                message: "",
                type: "",
            }),

            actions: {
                showMessage(message, type = "") {
                    this.isShow = true;
                    this.message = message;
                    this.type = type;
                },

                showErrorMessage(message) {
                    this.showMessage(message, "error");
                },
                showSuccessMessage(message) {
                    this.showMessage(message, "success");
                },
                showInfoMessage(message) {
                    this.showMessage(message, "info");
                },
                showWarningMessage(message) {
                    this.showMessage(message, "warning");
                },
                getIcon() {
                    const icon = {
                        info: "mdi-information",
                        success: "mdi-check-circle",
                        error: "mdi-alert-circle",
                        warning: "mdi-alert",
                    };

                    return icon[this.type];
                },
            },
        });

        const usePromptStore = defineStore("promptStore", {
            state: () => ({
                promptDialog: false,
                promptSheet: false,
                promptList: [],
                promptSelect: {},
                search: '',
                loading: false,
            }),
            actions: {
                loadPrompts: function () {
                    this.loading = true
                    try {
                        this.fetchPrompts().then((prompts) => {
                            console.log(prompts)
                            this.promptList = prompts
                            return
                        })
                    } catch (error) {
                        console.error('Failed to load prompts:', error);
                    } finally {
                        this.loading = false;
                    }

                },
                fetchPrompts: async function () {
                    const mcpStore = useMcpStore();
                    const mcpServers = mcpStore.getServers
                    if (!mcpServers) {
                        return []
                    }
                    const mcpKeys = Object.keys(mcpServers)
                    const allPrompts = []
                    for (const key of mcpKeys) {
                        const obj = await mcpServers[key]?.prompts?.list();
                        if (obj) {
                            obj.prompts.forEach(prompt => allPrompts.push({ title: key, ...prompt }));
                        }
                    }

                    return allPrompts;
                },
                select: function (prompt) {
                    console.log(prompt.title, prompt.name, prompt.arguments)
                    this.promptSelect = prompt
                    this.promptSheet = true
                    this.promptDialog = false
                },
                fetchSelect: async function () {
                    const mcpStore = useMcpStore();
                    const mcpServers = mcpStore.getServers
                    const getFun = mcpServers[this.promptSelect.title]?.prompts?.get
                    if (!getFun) {
                        return []
                    }
                    const params = { name: this.promptSelect.name }
                    if (this.promptSelect.arguments) {
                        for (const argument of this.promptSelect.arguments) {
                            if (argument.name) {
                                if (!params['arguments']) {
                                    params['arguments'] = {};
                                }
                                params['arguments'][argument.name] = argument.content
                            }
                        }
                    }

                    console.log(params)
                    const prompts = await getFun(params)

                    const conversations = prompts.messages.map(item => {
                        const content = mcpStore.convertItem(item.content)
                        const conversation = {
                            role: item.role,
                            content: item.role == 'user' ? [content] : content.text
                        }
                        return conversation
                    });

                    this.promptSheet = false

                    return conversations
                },
            },
        });

        const TuuiImgDialog = {
            template: '#tuui-img-dialog-template',
            props: { src: { type: String, required: true } }
        };


        const TuuiChatCard = defineComponent({
            template: '#tuui-chat-card-template',
            props: {
                index: { type: Number, required: true },
                range: { type: Number, required: false, default: 1 },
                messages: { type: Object, required: true },
                showContent: { type: Boolean, default: false },
                showDelete: { type: Boolean, default: true },
                showReduce: { type: Boolean, default: true },
                showModify: { type: Boolean, default: false },
                showCopy: { type: Boolean, default: true },
            },
            setup(props) {
                const showcontent = ref(false);
                const showmodify = ref(false);
                const snackbarStore = useSnackbarStore();

                const copyToClipboard = async (msg) => {
                    let textToCopy = '';
                    try {
                        if (typeof msg.content === 'string') {
                            textToCopy = msg.content;
                        } else if (Array.isArray(msg.content)) {
                            for (const item of msg.content) {
                                if (item.type === 'text' && typeof item.text === 'string') {
                                    textToCopy = item.text;
                                }
                            }
                        }
                        await navigator.clipboard.writeText(textToCopy);
                        snackbarStore.showSuccessMessage('$vuetify.dataIterator.snackbar.copied')
                    } catch (err) {
                        snackbarStore.showErrorMessage(err)
                    }
                };

                return {
                    copyToClipboard,
                    showcontent,
                    showmodify,
                };
            }
        });
        const TuuiChatBox = {
            template: '#tuui-chat-box-template',
            components: {
                TuuiImgDialog,
                TuuiChatCard,
            },
            props: {
                messages: { type: Array, required: true },
                size: { type: Number },
                language: { type: String }
            },
            setup(props) {
                const dialogs = reactive({});
                const groupMessages = computed(() => {
                    const groups = [];
                    props.messages.forEach((message, index) => {
                        if (message.role === 'user') {
                            groups.push({
                                index: index,
                                group: 'user',
                                message: message
                            })
                        } else if ((message.role === 'assistant') && (!message.tool_calls || message.tool_calls.length == 0)) {
                            groups.push({
                                index: index,
                                group: 'assistant',
                                message: message
                            })
                        } else {
                            const lastGroup = groups.at(-1)
                            if (lastGroup?.group == 'tool') {
                                lastGroup.messages.push(message)
                                dialogs[lastGroup.tab] = lastGroup.length
                                lastGroup.length += 1
                            } else {
                                const id = message.tool_call_id || message.tool_calls[0]?.id
                                groups.push({
                                    index: index,
                                    group: 'tool',
                                    tab: id,
                                    messages: [message],
                                    length: 1
                                })
                                dialogs[id] = 0
                            }
                        }
                    })
                    return groups
                });

                return {
                    dialogs,
                    groupMessages
                }
            }
        };

        const app = createApp({
            components: {
                vuedraggable,
                TuuiChatBox,
                TuuiChatCard
            },
            setup() {

                const snackbarStore = useSnackbarStore();
                const mcpStore = useMcpStore();
                const agentStore = useAgentStore();
                const settingStore = useSettingStore();
                const promptStore = usePromptStore();
                const resourceStore = useResourceStore();

                const { locale } = useI18n({ useScope: 'global' });

                const useLanguageStore = defineStore("languageStore", {
                    state: () => ({
                        list: [{ title: '', value: 'zhHans', name: 'china' },
                        // { title: 'Italiano', value: 'it', name: 'italy' },
                        // { title: '', value: 'ja', name: 'japan' },
                        // { title: 'Svenska', value: 'sv', name: 'sweden' },
                        { title: 'English', value: 'en', name: 'united-states' }]
                    }),
                    getters: {
                        getLocale: () => {
                            return locale.value
                        },
                    },
                    actions: {
                        change(lang) {
                            locale.value = lang;
                        },
                        getIcon(name) {
                            return `twemoji:flag-${name}`
                        },
                        getIcon2() {
                            const value = this.getLocale
                            const item = this.list.find(lang => lang.value === value);
                            return `twemoji:flag-${item.name}`
                        }
                    },
                });

                const useMessageStore = defineStore("messageStore", {
                    state: () => ({
                        userMessage: "",
                        conversation: [],
                        images: [],
                        base64: '',
                        generating: false
                    }),
                    actions: {
                        init() {
                            if (this.conversation.length === 0) {
                                snackbarStore.showWarningMessage('$vuetify.dataIterator.snackbar.addfail')
                            } else {
                                this.conversation = [];
                                snackbarStore.showSuccessMessage('$vuetify.dataIterator.snackbar.addnew')
                            }
                        },
                        stop() {
                            this.generating = false;
                            snackbarStore.showInfoMessage('$vuetify.dataIterator.snackbar.stopped')
                        },
                        clear() {
                            this.userMessage = "";
                            this.images = [];
                        },
                        handleKeydown(e) {
                            if (e.key === "Enter" && e.shiftKey) {
                                //  A new line by default
                            } else if (e.key === "Enter") {
                                // Only Enter is pressed, send message
                                e.preventDefault();
                                this.sendMessage();
                            }
                        },
                        resendMessage() {
                            // const conversation = this.conversation.reduce((newConversation, item) => {
                            let index = this.conversation.length - 1;
                            while (index >= 0 && this.conversation[index].role !== "user") {
                                index--;
                            }

                            // when role == "user" is founddrop followings
                            if (index >= 0) {
                                this.conversation.splice(index + 1);;
                                this.startInference();
                            }
                        },
                        sendMessage() {
                            if (this.userMessage) {
                                // Add the message to the list

                                const imageBase64 = this.base64;

                                this.conversation.push({
                                    content: imageBase64
                                        ? [
                                            { type: "image_url", image_url: { url: imageBase64 } },
                                            { type: "text", text: this.userMessage }
                                        ] : this.userMessage,
                                    role: "user",
                                });

                                if (this.conversation.length == 1) {
                                    historyStore.init(this.conversation)
                                }

                                this.startInference();
                            }
                        },
                        applyPrompt: async function (fetchedPrompt) {
                            const messages = await fetchedPrompt
                            console.log(messages)
                            this.conversation = messages

                        },
                        startInference: async function () {
                            console.log('[startInference] begin');
                            this.clear();
                            await createCompletion(this.conversation);
                            console.log('[startInference] after createCompletion');
                            await this.postToolCall()
                        },
                        postToolCall: async function () {
                            const last = this.conversation.at(-1)
                            if (!last || !last.tool_calls) {
                                return
                            }
                            if (last.tool_calls.length == 0) {
                                delete last.tool_calls
                                return
                            }
                            if (Object.keys(last.tool_calls[0]).length === 0) {
                                delete last.tool_calls
                                return
                            } else {
                                let tool_called = false
                                console.log(last.tool_calls)

                                const callNextTool = async (toolCalls, index) => {
                                    if (index >= toolCalls.length) {
                                        return;
                                    }

                                    const tool_call = toolCalls[index];

                                    try {
                                        const result = await mcpStore.callTool(
                                            tool_call.function.name,
                                            tool_call.function.arguments
                                        );

                                        console.log(result)

                                        if (result.content) {
                                            this.contentConvert(result.content, tool_call.id).forEach(item => {
                                                this.conversation.push(item);
                                            });
                                            tool_called = true;
                                        }

                                        await callNextTool(toolCalls, index + 1);
                                    } catch (error) {
                                        const result = mcpStore.packReturn(`Error calling tool: ${error}`)
                                        this.conversation.push({
                                            role: "tool",
                                            content: result.content,
                                            tool_call_id: tool_call.id
                                        });
                                        tool_called = true;
                                    }
                                };

                                await callNextTool(last.tool_calls, 0);

                                if (tool_called) {
                                    this.startInference()
                                }
                            }
                        },
                        contentConvert: function (content, toolCallId) {
                            const msg = content.map(item => mcpStore.convertItem(item));
                            console.log(msg)
                            if (msg.find(item => item.type === 'image_url')) {
                                return [{
                                    role: "tool",
                                    content: mcpStore.packReturn('Image provided in next user message').content,
                                    tool_call_id: toolCallId
                                }, {
                                    role: "user",
                                    content: msg,
                                },
                                ]
                            } else {
                                return [{
                                    role: "tool",
                                    content: msg.map(item => item.text).join('\n'), // If the LLM can support array in tool, use msg directly
                                    tool_call_id: toolCallId
                                }]
                            }
                        }
                    }
                });

                const useHistoryStore = defineStore("historyStore", {
                    state: () => ({
                        conversation: [],
                    }),
                    persist: {
                        enabled: true,
                        strategies: [{ storage: localStorage }],
                    },
                    getters: {
                        getDate: () => {
                            const date = new Date().toLocaleString('zh', { timeZoneName: 'short', hour12: false })
                            return date
                        },

                    },
                    actions: {
                        resetState() {
                            this.$reset();
                        },
                        deleteById(index) {
                            this.conversation.splice(index, 1);
                        },
                        init(conversation) {
                            this.conversation.unshift({
                                id: this.getDate,
                                history: conversation
                            });
                        },
                        replace(id) {
                            this.deleteById(id)
                            this.init(messageStore.conversation)
                        },
                        asyncReplace: async (id) => {
                            await nextTick();
                            historyStore.replace(id)
                        },
                        select(id) {
                            settingStore.configHistory = false
                            messageStore.conversation = this.conversation[id].history
                            this.asyncReplace(id)
                        },
                        getColor(id) {
                            const targetElement = this.conversation[id]?.history.find(element => element.role === "assistant");
                            if (targetElement) {
                                return "primary"
                            } else {
                                return "grey"
                            }

                        },
                        downloadById(id) {
                            const name = this.conversation[id].id.replace(/[/: ]/g, '-');
                            this.download(this.conversation[id].history, `history-${name}.json`);
                        },
                        downloadHistory() {
                            this.download(this.conversation, 'history.json')
                        },
                        download(json, filename) {
                            const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            a.click();
                            URL.revokeObjectURL(url);
                        }
                    }
                });


                const useDefaultChoiceStore = defineStore("defaultChoiceStore", {
                    state: () => ({
                        url: [],
                        path: [
                            "/chat/completions",
                            "/v1/chat/completions",],
                        model: [
                            "Qwen/Qwen3-32B",
                            "Qwen/Qwen3-Coder-480B-A35B-Instruct-Turbo",
                        ],
                        authPrefix: [],
                        max_tokens_type: ["max_tokens", "max_completion_tokens", "max_new_tokens"],
                        reasoning_efforts: ['false', 'none', 'low', 'medium', 'high']
                    }),
                    persist: {
                        enabled: true,
                        strategies: [{ storage: localStorage }],
                        // paths: ["apiKey"] 
                    },
                    actions: {
                        resetState() {
                            this.$reset();
                        },
                        updateStoreFromJSON(json) {
                            this.$reset();
                            this.$state = json;
                        }
                    },
                });


                const useChatbotStore = defineStore("chatbotStore", {
                    state: () => ({
                        apiKey: "",
                        url: "https://api2.aiql.com",
                        path: "/chat/completions",
                        model: "Qwen/Qwen3-32B",
                        authPrefix: "Bearer",
                        contentType: "application/json",
                        max_tokens_type: "max_tokens",
                        max_tokens_value: "",
                        temperature: "",
                        top_p: "",
                        method: "POST",
                        stream: true,
                        thinking: true,
                        reasoning_effort: null,
                        mcp: true
                    }),

                    persist: {
                        enabled: true,
                        strategies: [{ storage: localStorage }],
                        // paths: ["apiKey"] 
                    },

                    actions: {
                        resetState() {
                            this.$reset();
                            defaultChoiceStore.resetState()
                        },
                        updateStoreFromJSON(json) {
                            this.$reset();
                            this.$state = json;
                        }
                    },

                });

                const chatbotStore = useChatbotStore();
                const messageStore = useMessageStore();
                const historyStore = useHistoryStore();
                const defaultChoiceStore = useDefaultChoiceStore();
                const languageStore = useLanguageStore();

                const createCompletion = async (rawconversation) => {
                    console.log('[createCompletion] called', { length: rawconversation?.length });
                    const conversation = rawconversation.reduce((newConversation, item) => {
                        if (item.role === "assistant") {
                            const { reasoning_content, ...rest } = item;
                            newConversation.push(rest);
                        }
                        // (item.role === "user" && item.content[0].type === "image_url") {
                        //     // Image is too large, only latest query could be kept
                        //     newConversation = [item];
                        // }
                        else {
                            newConversation.push(item);
                        }
                        return newConversation;
                    }, []);
                    // const conversation = rawconversation
                    try {
                        messageStore.generating = true
                        // Create a completion (axios is not used here because it does not support streaming)
                        const headers = {
                            "Content-Type": chatbotStore.contentType,
                        };

                        if (chatbotStore.apiKey) headers.Token = `${chatbotStore.authPrefix} ${chatbotStore.apiKey}`

                        const body = {
                            messages: agentStore.promptMessage(conversation),
                            model: chatbotStore.model,
                            stream: chatbotStore.stream,
                        }

                        if (chatbotStore.max_tokens_value) {
                            body[chatbotStore.max_tokens_type] = parseInt(chatbotStore.max_tokens_value)
                        }

                        if (typeof chatbotStore.reasoning_effort === 'string') {
                            if (chatbotStore.reasoning_effort === 'false') {
                                // For Python API backends such as extra_body.chat_template_kwargs
                                body['chat_template_kwargs'] = { enable_thinking: false }
                            } else {
                                // For OpenAI OpenAPI backends such as ChatGPT or DeepInfra
                                body['reasoning_effort'] = chatbotStore.reasoning_effort
                            }
                        }

                        if (chatbotStore.temperature) {
                            body["temperature"] = parseFloat(chatbotStore.temperature)
                        }

                        if (chatbotStore.top_p) {
                            body["top_p"] = parseFloat(chatbotStore.top_p)
                        }
                        
                        try {
                        console.log('[createCompletion] pre-mcp logs');
                        console.log(`chatbotStore.mcp: ${chatbotStore.mcp}`)
                        } catch (e) {
                            console.error(e)
                        }
                        if (chatbotStore.mcp) {
                            console.log("1")
                            body["tools"] = await mcpStore.listTools()
                            console.log("2")
                        }
                        console.log(`body: ${JSON.stringify(body)}`)

                        const request = {
                            headers: headers,
                            method: chatbotStore.method,
                            body: JSON.stringify(body),
                        };

                        const completion = await fetch(
                            chatbotStore.url + (chatbotStore.path ? chatbotStore.path : ''),
                            request
                        );

                        console.log(completion)

                        // Handle errors
                        if (!completion.ok) {
                            const errorData = await completion.json();
                            console.log(errorData.error?.message);
                            if (errorData.error?.message)
                                snackbarStore.showErrorMessage(`${completion.status}: ${errorData.error.message}`);
                            else if (errorData.detail[0]?.msg)
                                snackbarStore.showErrorMessage(`${completion.status}${(" - " + errorData.detail[0]?.loc + ":") || ":"} ${errorData.detail[0]?.msg}`);
                            else
                                snackbarStore.showErrorMessage(`${completion.status}: ${completion.statusText}`);
                            return;
                        }

                        // Create a reader
                        const reader = completion.body?.getReader();
                        if (!reader) {
                            snackbarStore.showErrorMessage('$vuetify.dataIterator.snackbar.parseStreamFail');
                        }

                        // Add the bot message
                        messageStore.conversation.push({
                            content: "",
                            reasoning_content: "",
                            tool_calls: [],
                            role: "assistant",
                        });

                        let buffer = ''

                        // Read the stream
                        await read(reader, messageStore.conversation.at(-1), buffer, chatbotStore.stream);
                    } catch (error) {
                        console.log(`Request completion error: ${error.message}`)
                        snackbarStore.showErrorMessage(error.message);
                    } finally {
                        console.log("Finish createCompletion")
                        messageStore.generating = false
                    }
                };

                const read = async (
                    reader,
                    target,
                    buffer,
                    stream
                ) => {
                    // TextDecoder is a built-in object that allows you to convert a stream of bytes into a string
                    const decoder = new TextDecoder();
                    // Destructure the value returned by reader.read()
                    const { done, value } = await reader.read();

                    // If the stream is done reading, release the lock on the reader
                    if (done || !messageStore.generating) {
                        messageStore.generating = false;
                        return reader.releaseLock();
                    }
                    // Convert the stream of bytes into a string
                    const chunks = decoder.decode(value);

                    if (stream) {
                        // Split stream
                        let parts = chunks.split('\n')

                        if (parts.length === 1) {
                            buffer += parts[0]
                            return read(reader, target, buffer, stream);
                        }

                        if (buffer.length > 0) {
                            parts[0] = buffer + parts[0];
                            buffer = ''
                        }

                        const last = parts[parts.length - 1];
                        if (last && last.length > 0) {
                            buffer = parts.pop();
                        }

                        parts
                            .map((line) => line.trim())
                            .filter((line) => line.length > 0)
                            .forEach((line) => {
                                const pos = line.indexOf(':');
                                const name = line.substring(0, pos);
                                if (name !== 'data') {
                                    return
                                }
                                const content = line.substring(pos + 1).trim()
                                if (content.length === 0) {
                                    return
                                } else if (content === "[DONE]") {
                                    return
                                }
                                parseJson(content, target)
                            })

                    } else {
                        parseJson(chunks, target)
                    }

                    // Repeat the process
                    return read(reader, target, buffer, stream);
                };

                const parseJson = (content, target) => {
                    try {
                        const parsed = JSON.parse(content)
                        // const choice = 
                        parseChoices(parsed, target)
                        // parseChoice(choice, target)
                    } catch (e) {
                        console.log(e, content)
                        parseChoice(content, target)
                    }
                };

                const parseChoices = (parsed, target) => {
                    if ('choices' in parsed) {
                        return parsed.choices.map((choice) => {
                            const content = choice.delta || choice.message
                            return parseChoice(content, target)
                        })
                    } else if ('response' in parsed) {
                        return parseChoice(parsed.response, target)
                    } else {
                        return parseChoice(parsed, target)
                    }
                };

                const parseChoice = (choice, target) => {
                    if (choice) {
                        if (target.role == 'assistant') {
                            if (typeof choice === 'string') {
                                target.content += choice;
                            } else {
                                if (typeof choice.content === 'string') {
                                    target.content += choice.content;
                                }
                                if (typeof choice.reasoning_content === 'string') {
                                    target.reasoning_content += choice.reasoning_content;
                                }
                            }
                            parseTool(choice.tool_calls, target)
                        }
                    }
                };

                const parseTool = (tools, target) => {
                    if (tools) {
                        tools.map((tool) => {
                            const lastTool = target.tool_calls.at(-1)
                            if (lastTool && (!tool.id || lastTool.id == tool.id)) {
                                const source = tool.function
                                for (const key in source) {
                                    // Determine if source[key] is null, skip if it is null
                                    if (source[key] === null) {
                                        continue;
                                    }
                                    if (lastTool.function[key]) {
                                        lastTool.function[key] += source[key];
                                    } else {
                                        lastTool.function[key] = source[key];
                                    }
                                }

                            } else {
                                target.tool_calls.push(tool)
                            }
                        })
                    }
                };

                watch(computed(() => messageStore.conversation.at(-1)?.content),
                    (newValue, oldValue) => {
                        if (newValue !== oldValue) {
                            asyncScrollToBottom();
                        }
                    }, { deep: true });

                watch(computed(() => messageStore.images),
                    (newValue, oldValue) => {
                        if (newValue.length === 0) {
                            messageStore.base64 = '';
                        } else {
                            const file = messageStore.images; // Assuming you're working with a single image
                            const reader = new FileReader();
                            const MAX_WIDTH = 2048;
                            const MAX_HEIGHT = 2048; // adjust these values as needed

                            reader.onload = (e) => {
                                const img = new Image();
                                img.onload = () => {
                                    let width = img.width;
                                    let height = img.height;
                                    let quality = 0.8;

                                    // Check if the image exceeds the maximum dimensions
                                    if (width > MAX_WIDTH || height > MAX_HEIGHT) {
                                        // Calculate the scaling factor
                                        const scaleFactor = Math.min(MAX_WIDTH / width, MAX_HEIGHT / height);

                                        // Resize the image
                                        width *= scaleFactor;
                                        height *= scaleFactor;
                                        quality *= scaleFactor;

                                    }

                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');

                                    // Set canvas dimensions to match the resized image
                                    canvas.width = width;
                                    canvas.height = height;

                                    // Draw the image on the canvas
                                    ctx.drawImage(img, 0, 0, width, height);

                                    // Convert the canvas to a PNG data URL
                                    const pngDataUrl = canvas.toDataURL('image/jpeg', quality);

                                    // Store the PNG data URL in messageStore.base64
                                    messageStore.base64 = pngDataUrl;
                                };
                                img.src = e.target.result;
                            };
                            reader.readAsDataURL(file);
                        }
                    }, { deep: true });

                const asyncScrollToBottom = async () => {
                    // await nextTick();
                    requestAnimationFrame(() => {
                        scrollToBottom(document.querySelector(".chat-bot"));
                    });
                }

                const scrollToBottom = (
                    element,
                    options = { behavior: "auto" }
                ) => {
                    window.scrollTo({
                        ...options,
                        top: element?.scrollHeight
                    });
                };

                const initLottie = () => {
                    lottie.loadAnimation({
                        container: document.getElementById('lottie'), // the dom element that will contain the animation
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        path: '../lib/anime/lottie.json' // the path to the animation json
                    });
                };

                onMounted(async () => {
                    initLottie();
                    agentStore.initAgent();
                    settingStore.refreshMcpServersList();
                    resizeAvatar()
                    window.onresize = () => resizeAvatar()
                    resizeInputBox()
                });

                const resizeInputBox = () => {
                    const inputBox = document.querySelector(".input-box");
                    const handleResize = (entries) => {
                        for (const entry of entries) {
                            if (entry.target === inputBox) {
                                const chatElement = document.querySelector(".chat-bot");
                                if (chatElement) {
                                    chatElement.style.marginBottom = `${Math.max(entry.contentRect.height, 122)}px`
                                }
                            }
                        }
                    };
                    const resizeObserver = new ResizeObserver(handleResize);
                    if (inputBox) {
                        resizeObserver.observe(inputBox);
                    }
                };

                const resizeAvatar = () => {
                    // console.log(window.innerWidth)
                    if (window.innerWidth <= 1279) {
                        settingStore.avatarSize = 26
                    } else {
                        settingStore.avatarSize = 36
                    }
                };

                const configFile = ref(null)

                watch(configFile, (newValue, oldValue) => {
                    if (newValue) {

                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const json = JSON.parse(event.target.result)
                                chatbotStore.updateStoreFromJSON(json.chatbotStore)
                                defaultChoiceStore.updateStoreFromJSON(json.defaultChoiceStore)
                            } catch {
                                snackbarStore.showErrorMessage('$vuetify.dataIterator.snackbar.parseConfigFail')
                            }

                        };
                        reader.readAsText(newValue);
                    }
                });

                watch(computed(() => agentStore.card?.refFile),
                    (newValue, oldValue) => {
                        const reader = new FileReader();
                        if (agentStore.card?.refFile === null) {
                            agentStore.card.refText = ""
                            return
                        }
                        if (newValue?.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
                            reader.onload = (event) => {
                                mammoth.extractRawText({ arrayBuffer: event.target.result })
                                    .then(function (result) {
                                        var text = result.value; // The raw text
                                        agentStore.card.refText = text
                                        // var messages = result.messages; // The warning
                                    })
                                    .catch(function (error) {
                                        console.error(error);
                                    });
                            };
                            reader.readAsArrayBuffer(newValue);
                        } else if (newValue?.name?.length > 0) {
                            reader.onload = (event) => {
                                agentStore.card.refText = event.target.result
                            };
                            reader.readAsText(newValue);
                        }

                    }, { deep: true });

                document.fonts.ready.then(() => {
                    settingStore.fontStatus = true
                });

                const resetALL = () => {
                    historyStore.resetState()
                    chatbotStore.resetState()
                    defaultChoiceStore.resetState()
                };

                return {
                    configFile,

                    settingStore,
                    promptStore,
                    resourceStore,
                    agentStore,
                    snackbarStore,
                    mcpStore,

                    messageStore,
                    defaultChoiceStore,
                    chatbotStore,
                    historyStore,

                    languageStore,

                    resetALL,

                };
            }

        })

        const messages = {
            en: {
                $vuetify: {
                    ...en,
                    dataIterator: {
                        title: 'CUIGUO Workstattion',
                        q: { title: 'Query History' },
                        p: {
                            title: 'Prompts Template',
                            sheet: 'Prompts Sheet',
                            inuse: 'In Use',
                            standby: 'Standby'
                        },
                        l: { title: 'Language' },
                        a: { title: 'Prompts & MCP' },
                        r: { title: 'Resources' },
                        g: {
                            new: 'New Conversation',
                            reg: 'Regeneration'
                        },
                        i: {
                            title: 'Model Integration',
                            apikey: 'API Key',
                            reasoning: 'Reasoning Effort',
                            endpoint: 'Endpoint',
                            url: 'URL',
                            path: 'Path',
                            model: 'Model',
                            advanced: 'Advanced',
                            method: 'HTTP Method',
                            stream: 'Stream',
                            mcp: 'MCP',
                            maxTokensPrefix: 'Max Tokens Prefix',
                            temperature: 'Temperature',
                            topP: 'Top P',
                            contentType: 'Content Type',
                            authPrefix: 'Auth Prefix',
                            configFile: 'Config File'
                        },
                        snackbar: {
                            addnew: 'Added new session.',
                            addfail: 'Already in a fresh session.',
                            stopped: 'Generating stopped.',
                            parseStreamFail: 'Cannot read the stream.',
                            parseConfigFail: 'Cannot parse the config file.',
                            copied: 'Copied to clipboard.'
                        }
                    },
                },
            },
            zhHans: {
                $vuetify: {
                    ...zhHans,
                    dataIterator: {
                        title: '',
                        q: { title: '' },
                        l: { title: '' },
                        p: {
                            title: 'MCP',
                            sheet: 'MCP'
                        },
                        a: { title: 'MCP' },
                        r: { title: '' },
                        g: {
                            new: '',
                            reg: ''
                        },
                        i: {
                            title: '',
                            apikey: 'API ',
                            endpoint: '',
                            reasoning: '',
                            url: '',
                            path: '',
                            model: '',
                            advanced: '',
                            method: 'HTTP ',
                            stream: '',
                            maxTokensPrefix: '',
                            temperature: '',
                            topP: '',
                            contentType: '',
                            authPrefix: '',
                            configFile: ''
                        },
                        snackbar: {
                            addnew: '',
                            addfail: '',
                            stopped: '',
                            parseStreamFail: '',
                            parseConfigFail: '',
                            copied: ''
                        }
                    },
                },
            },
        }

        const i18n = createI18n({
            legacy: false, // Vuetify does not support the legacy mode of vue-i18n
            locale: 'zhHans',
            fallbackLocale: 'zhHans',
            messages,
        })

        const vuetify = createVuetify({
            locale: {
                adapter: { i18n, useI18n },
            },
        })
        const pinia = createPinia()

        pinia.use(piniaPersist.default)

        app.use(i18n)
        app.use(vuetify)
        app.use(pinia)
        app.use(MdEditorV3.MdPreview)

        app.mount('#app')

    </script>
</body>

</html>